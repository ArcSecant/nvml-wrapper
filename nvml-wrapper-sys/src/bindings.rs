/* automatically generated by rust-bindgen */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use std::os::raw;

pub const NVML_API_VERSION: raw::c_uint = 8;
pub const NVML_API_VERSION_STR: &'static [u8; 2usize] = b"8\x00";
pub const NVML_VALUE_NOT_AVAILABLE: raw::c_int = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: raw::c_uint = 16;
pub const NVML_NVLINK_MAX_LINKS: raw::c_uint = 4;
pub const NVML_MAX_PHYSICAL_BRIDGE: raw::c_uint = 128;
pub const nvmlFlagDefault: raw::c_uint = 0;
pub const nvmlFlagForce: raw::c_uint = 1;
pub const nvmlEventTypeSingleBitEccError: raw::c_uint = 1;
pub const nvmlEventTypeDoubleBitEccError: raw::c_uint = 2;
pub const nvmlEventTypePState: raw::c_uint = 4;
pub const nvmlEventTypeXidCriticalError: raw::c_uint = 8;
pub const nvmlEventTypeClock: raw::c_uint = 16;
pub const nvmlEventTypeNone: raw::c_uint = 0;
pub const nvmlEventTypeAll: raw::c_uint = 31;
pub const nvmlClocksThrottleReasonGpuIdle: raw::c_uint = 1;
pub const nvmlClocksThrottleReasonApplicationsClocksSetting: raw::c_uint = 2;
pub const nvmlClocksThrottleReasonUserDefinedClocks: raw::c_uint = 2;
pub const nvmlClocksThrottleReasonSwPowerCap: raw::c_uint = 4;
pub const nvmlClocksThrottleReasonHwSlowdown: raw::c_uint = 8;
pub const nvmlClocksThrottleReasonSyncBoost: raw::c_uint = 16;
pub const nvmlClocksThrottleReasonUnknown: raw::c_longlong =
    -9223372036854775808;
pub const nvmlClocksThrottleReasonNone: raw::c_uint = 0;
pub const nvmlClocksThrottleReasonAll: raw::c_longlong = -9223372036854775777;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: raw::c_uint = 16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: raw::c_uint = 80;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: raw::c_uint = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: raw::c_uint = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: raw::c_uint = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: raw::c_uint = 64;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: raw::c_uint = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: raw::c_uint = 32;
#[repr(C)]
#[derive(Debug)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlPciInfo_st {
    pub busId: [raw::c_char; 16usize],
    pub domain: raw::c_uint,
    pub bus: raw::c_uint,
    pub device: raw::c_uint,
    pub pciDeviceId: raw::c_uint,
    pub pciSubSystemId: raw::c_uint,
    pub reserved0: raw::c_uint,
    pub reserved1: raw::c_uint,
    pub reserved2: raw::c_uint,
    pub reserved3: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlPciInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlPciInfo_st>() , 52usize , concat ! (
               "Size of: " , stringify ! ( nvmlPciInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlPciInfo_st>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nvmlPciInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . busId as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( busId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . domain as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . bus as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . device as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . pciDeviceId as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( pciDeviceId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . pciSubSystemId as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( pciSubSystemId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . reserved0 as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( reserved0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . reserved1 as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . reserved2 as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . reserved3 as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( reserved3 ) ));
}
impl Clone for nvmlPciInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlEccErrorCounts_st {
    pub l1Cache: raw::c_ulonglong,
    pub l2Cache: raw::c_ulonglong,
    pub deviceMemory: raw::c_ulonglong,
    pub registerFile: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEccErrorCounts_st() {
    assert_eq!(::std::mem::size_of::<nvmlEccErrorCounts_st>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlEccErrorCounts_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlEccErrorCounts_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlEccErrorCounts_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . l1Cache as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( l1Cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . l2Cache as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( l2Cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . deviceMemory
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( deviceMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . registerFile
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( registerFile ) ));
}
impl Clone for nvmlEccErrorCounts_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlUtilization_st {
    pub gpu: raw::c_uint,
    pub memory: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUtilization_st() {
    assert_eq!(::std::mem::size_of::<nvmlUtilization_st>() , 8usize , concat !
               ( "Size of: " , stringify ! ( nvmlUtilization_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUtilization_st>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlUtilization_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUtilization_st ) ) . gpu as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUtilization_st ) ,
                "::" , stringify ! ( gpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUtilization_st ) ) . memory as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUtilization_st ) ,
                "::" , stringify ! ( memory ) ));
}
impl Clone for nvmlUtilization_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlMemory_st {
    pub total: raw::c_ulonglong,
    pub free: raw::c_ulonglong,
    pub used: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlMemory_st() {
    assert_eq!(::std::mem::size_of::<nvmlMemory_st>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nvmlMemory_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlMemory_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlMemory_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . total as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . free as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . used as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( used ) ));
}
impl Clone for nvmlMemory_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlMemory_t = nvmlMemory_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlBAR1Memory_st {
    pub bar1Total: raw::c_ulonglong,
    pub bar1Free: raw::c_ulonglong,
    pub bar1Used: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlBAR1Memory_st() {
    assert_eq!(::std::mem::size_of::<nvmlBAR1Memory_st>() , 24usize , concat !
               ( "Size of: " , stringify ! ( nvmlBAR1Memory_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlBAR1Memory_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlBAR1Memory_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Total as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Free as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Used as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Used ) ));
}
impl Clone for nvmlBAR1Memory_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlProcessInfo_st {
    pub pid: raw::c_uint,
    pub usedGpuMemory: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlProcessInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlProcessInfo_st>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( nvmlProcessInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlProcessInfo_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlProcessInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessInfo_st ) ) . pid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlProcessInfo_st ) ,
                "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessInfo_st ) ) . usedGpuMemory as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlProcessInfo_st ) ,
                "::" , stringify ! ( usedGpuMemory ) ));
}
impl Clone for nvmlProcessInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_PLX:
          nvmlBridgeChipType_enum =
    0;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_BRO4:
          nvmlBridgeChipType_enum =
    1;
pub type nvmlBridgeChipType_enum = raw::c_uint;
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_CYCLES:
          nvmlNvLinkUtilizationCountUnits_enum =
    0;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_PACKETS:
          nvmlNvLinkUtilizationCountUnits_enum =
    1;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_BYTES:
          nvmlNvLinkUtilizationCountUnits_enum =
    2;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_COUNT:
          nvmlNvLinkUtilizationCountUnits_enum =
    3;
pub type nvmlNvLinkUtilizationCountUnits_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountUnits_enum as
        nvmlNvLinkUtilizationCountUnits_t;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NOP:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    1;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_READ:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    2;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_WRITE:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    4;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RATOM:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    8;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NRATOM:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    16;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_FLUSH:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    32;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    64;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    128;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_ALL:
          nvmlNvLinkUtilizationCountPktTypes_enum =
    255;
pub type nvmlNvLinkUtilizationCountPktTypes_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as
        nvmlNvLinkUtilizationCountPktTypes_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
#[test]
fn bindgen_test_layout_nvmlNvLinkUtilizationControl_st() {
    assert_eq!(::std::mem::size_of::<nvmlNvLinkUtilizationControl_st>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( nvmlNvLinkUtilizationControl_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlNvLinkUtilizationControl_st>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlNvLinkUtilizationControl_st ) ) .
                units as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) , "::" , stringify ! ( units
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlNvLinkUtilizationControl_st ) ) .
                pktfilter as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) , "::" , stringify ! (
                pktfilter ) ));
}
impl Clone for nvmlNvLinkUtilizationControl_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_SUPPORTED:
          nvmlNvLinkCapability_enum =
    0;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ACCESS:
          nvmlNvLinkCapability_enum =
    1;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_ATOMICS:
          nvmlNvLinkCapability_enum =
    2;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ATOMICS:
          nvmlNvLinkCapability_enum =
    3;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SLI_BRIDGE:
          nvmlNvLinkCapability_enum =
    4;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_VALID:
          nvmlNvLinkCapability_enum =
    5;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_COUNT:
          nvmlNvLinkCapability_enum =
    6;
pub type nvmlNvLinkCapability_enum = raw::c_uint;
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_REPLAY:
          nvmlNvLinkErrorCounter_enum =
    0;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_RECOVERY:
          nvmlNvLinkErrorCounter_enum =
    1;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_FLIT:
          nvmlNvLinkErrorCounter_enum =
    2;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_DATA:
          nvmlNvLinkErrorCounter_enum =
    3;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_COUNT:
          nvmlNvLinkErrorCounter_enum =
    4;
pub type nvmlNvLinkErrorCounter_enum = raw::c_uint;
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = 0;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = 10;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = 20;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = 30;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_CPU: nvmlGpuLevel_enum = 40;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = 50;
pub type nvmlGpuLevel_enum = raw::c_uint;
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = 0;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED:
          nvmlGpuP2PStatus_enum =
    1;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_GPU_NOT_SUPPORTED:
          nvmlGpuP2PStatus_enum =
    2;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED:
          nvmlGpuP2PStatus_enum =
    3;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_DISABLED_BY_REGKEY:
          nvmlGpuP2PStatus_enum =
    4;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_NOT_SUPPORTED:
          nvmlGpuP2PStatus_enum =
    5;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum
          =
    6;
pub type nvmlGpuP2PStatus_enum = raw::c_uint;
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_READ:
          nvmlGpuP2PCapsIndex_enum =
    0;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_WRITE:
          nvmlGpuP2PCapsIndex_enum =
    1;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_NVLINK:
          nvmlGpuP2PCapsIndex_enum =
    2;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_ATOMICS:
          nvmlGpuP2PCapsIndex_enum =
    3;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_PROP:
          nvmlGpuP2PCapsIndex_enum =
    4;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_UNKNOWN:
          nvmlGpuP2PCapsIndex_enum =
    5;
pub type nvmlGpuP2PCapsIndex_enum = raw::c_uint;
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlBridgeChipInfo_st {
    pub type_: nvmlBridgeChipType_t,
    pub fwVersion: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlBridgeChipInfo_st>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlBridgeChipInfo_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlBridgeChipInfo_st>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlBridgeChipInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipInfo_st ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBridgeChipInfo_st )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipInfo_st ) ) . fwVersion as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBridgeChipInfo_st )
                , "::" , stringify ! ( fwVersion ) ));
}
impl Clone for nvmlBridgeChipInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[repr(C)]
pub struct nvmlBridgeChipHierarchy_st {
    pub bridgeCount: raw::c_uchar,
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipHierarchy_st() {
    assert_eq!(::std::mem::size_of::<nvmlBridgeChipHierarchy_st>() , 1028usize
               , concat ! (
               "Size of: " , stringify ! ( nvmlBridgeChipHierarchy_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlBridgeChipHierarchy_st>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( nvmlBridgeChipHierarchy_st )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipHierarchy_st ) ) .
                bridgeCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlBridgeChipHierarchy_st ) , "::" , stringify ! (
                bridgeCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipHierarchy_st ) ) .
                bridgeChipInfo as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlBridgeChipHierarchy_st ) , "::" , stringify ! (
                bridgeChipInfo ) ));
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
pub const nvmlSamplingType_enum_NVML_TOTAL_POWER_SAMPLES:
          nvmlSamplingType_enum =
    0;
pub const nvmlSamplingType_enum_NVML_GPU_UTILIZATION_SAMPLES:
          nvmlSamplingType_enum =
    1;
pub const nvmlSamplingType_enum_NVML_MEMORY_UTILIZATION_SAMPLES:
          nvmlSamplingType_enum =
    2;
pub const nvmlSamplingType_enum_NVML_ENC_UTILIZATION_SAMPLES:
          nvmlSamplingType_enum =
    3;
pub const nvmlSamplingType_enum_NVML_DEC_UTILIZATION_SAMPLES:
          nvmlSamplingType_enum =
    4;
pub const nvmlSamplingType_enum_NVML_PROCESSOR_CLK_SAMPLES:
          nvmlSamplingType_enum =
    5;
pub const nvmlSamplingType_enum_NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum
          =
    6;
pub const nvmlSamplingType_enum_NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum
          =
    7;
pub type nvmlSamplingType_enum = raw::c_uint;
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_TX_BYTES:
          nvmlPcieUtilCounter_enum =
    0;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_RX_BYTES:
          nvmlPcieUtilCounter_enum =
    1;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_COUNT:
          nvmlPcieUtilCounter_enum =
    2;
pub type nvmlPcieUtilCounter_enum = raw::c_uint;
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = 0;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum
          =
    1;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum
          =
    2;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG_LONG:
          nvmlValueType_enum =
    3;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = 4;
pub type nvmlValueType_enum = raw::c_uint;
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[repr(C)]
#[derive(Copy)]
#[cfg(feature = "nightly")]
pub union nvmlValue_st {
    pub dVal: f64,
    pub uiVal: raw::c_uint,
    pub ulVal: raw::c_ulong,
    pub ullVal: raw::c_ulonglong,
}
#[test]
#[cfg(feature = "nightly")]
fn bindgen_test_layout_nvmlValue_st() {
    assert_eq!(::std::mem::size_of::<nvmlValue_st>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nvmlValue_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlValue_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlValue_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . dVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( dVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . uiVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( uiVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . ulVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( ulVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . ullVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( ullVal ) ));
}
#[cfg(feature = "nightly")]
impl Clone for nvmlValue_st {
    fn clone(&self) -> Self { *self }
}
#[cfg(feature = "nightly")]
pub type nvmlValue_t = nvmlValue_st;
#[repr(C)]
#[derive(Copy)]
#[cfg(feature = "nightly")]
pub struct nvmlSample_st {
    pub timeStamp: raw::c_ulonglong,
    pub sampleValue: nvmlValue_t,
}
#[test]
#[cfg(feature = "nightly")]
fn bindgen_test_layout_nvmlSample_st() {
    assert_eq!(::std::mem::size_of::<nvmlSample_st>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nvmlSample_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlSample_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlSample_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlSample_st ) ) . timeStamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlSample_st ) , "::"
                , stringify ! ( timeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlSample_st ) ) . sampleValue as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlSample_st ) , "::"
                , stringify ! ( sampleValue ) ));
}
#[cfg(feature = "nightly")]
impl Clone for nvmlSample_st {
    fn clone(&self) -> Self { *self }
}
#[cfg(feature = "nightly")]
pub type nvmlSample_t = nvmlSample_st;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_POWER:
          nvmlPerfPolicyType_enum =
    0;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_THERMAL:
          nvmlPerfPolicyType_enum =
    1;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_SYNC_BOOST:
          nvmlPerfPolicyType_enum =
    2;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_COUNT:
          nvmlPerfPolicyType_enum =
    3;
pub type nvmlPerfPolicyType_enum = raw::c_uint;
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlViolationTime_st {
    pub referenceTime: raw::c_ulonglong,
    pub violationTime: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlViolationTime_st() {
    assert_eq!(::std::mem::size_of::<nvmlViolationTime_st>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlViolationTime_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlViolationTime_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlViolationTime_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlViolationTime_st ) ) . referenceTime
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlViolationTime_st )
                , "::" , stringify ! ( referenceTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlViolationTime_st ) ) . violationTime
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlViolationTime_st )
                , "::" , stringify ! ( violationTime ) ));
}
impl Clone for nvmlViolationTime_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
pub const nvmlEnableState_enum_NVML_FEATURE_DISABLED: nvmlEnableState_enum =
    0;
pub const nvmlEnableState_enum_NVML_FEATURE_ENABLED: nvmlEnableState_enum = 1;
pub type nvmlEnableState_enum = raw::c_uint;
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
pub const nvmlBrandType_enum_NVML_BRAND_UNKNOWN: nvmlBrandType_enum = 0;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO: nvmlBrandType_enum = 1;
pub const nvmlBrandType_enum_NVML_BRAND_TESLA: nvmlBrandType_enum = 2;
pub const nvmlBrandType_enum_NVML_BRAND_NVS: nvmlBrandType_enum = 3;
pub const nvmlBrandType_enum_NVML_BRAND_GRID: nvmlBrandType_enum = 4;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE: nvmlBrandType_enum = 5;
pub const nvmlBrandType_enum_NVML_BRAND_COUNT: nvmlBrandType_enum = 6;
pub type nvmlBrandType_enum = raw::c_uint;
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SHUTDOWN:
          nvmlTemperatureThresholds_enum =
    0;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SLOWDOWN:
          nvmlTemperatureThresholds_enum =
    1;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_COUNT:
          nvmlTemperatureThresholds_enum =
    2;
pub type nvmlTemperatureThresholds_enum = raw::c_uint;
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_GPU:
          nvmlTemperatureSensors_enum =
    0;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_COUNT:
          nvmlTemperatureSensors_enum =
    1;
pub type nvmlTemperatureSensors_enum = raw::c_uint;
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum
          =
    0;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_THREAD:
          nvmlComputeMode_enum =
    1;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_PROHIBITED:
          nvmlComputeMode_enum =
    2;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_PROCESS:
          nvmlComputeMode_enum =
    3;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum =
    4;
pub type nvmlComputeMode_enum = raw::c_uint;
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_CORRECTED:
          nvmlMemoryErrorType_enum =
    0;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_UNCORRECTED:
          nvmlMemoryErrorType_enum =
    1;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_COUNT:
          nvmlMemoryErrorType_enum =
    2;
pub type nvmlMemoryErrorType_enum = raw::c_uint;
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
pub const nvmlEccCounterType_enum_NVML_VOLATILE_ECC: nvmlEccCounterType_enum =
    0;
pub const nvmlEccCounterType_enum_NVML_AGGREGATE_ECC: nvmlEccCounterType_enum
          =
    1;
pub const nvmlEccCounterType_enum_NVML_ECC_COUNTER_TYPE_COUNT:
          nvmlEccCounterType_enum =
    2;
pub type nvmlEccCounterType_enum = raw::c_uint;
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
pub const nvmlClockType_enum_NVML_CLOCK_GRAPHICS: nvmlClockType_enum = 0;
pub const nvmlClockType_enum_NVML_CLOCK_SM: nvmlClockType_enum = 1;
pub const nvmlClockType_enum_NVML_CLOCK_MEM: nvmlClockType_enum = 2;
pub const nvmlClockType_enum_NVML_CLOCK_VIDEO: nvmlClockType_enum = 3;
pub const nvmlClockType_enum_NVML_CLOCK_COUNT: nvmlClockType_enum = 4;
pub type nvmlClockType_enum = raw::c_uint;
pub use self::nvmlClockType_enum as nvmlClockType_t;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = 0;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum =
    1;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum =
    2;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum
          =
    3;
pub const nvmlClockId_enum_NVML_CLOCK_ID_COUNT: nvmlClockId_enum = 4;
pub type nvmlClockId_enum = raw::c_uint;
pub use self::nvmlClockId_enum as nvmlClockId_t;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDDM: nvmlDriverModel_enum = 0;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDM: nvmlDriverModel_enum = 1;
pub type nvmlDriverModel_enum = raw::c_uint;
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
pub const nvmlPStates_enum_NVML_PSTATE_0: nvmlPStates_enum = 0;
pub const nvmlPStates_enum_NVML_PSTATE_1: nvmlPStates_enum = 1;
pub const nvmlPStates_enum_NVML_PSTATE_2: nvmlPStates_enum = 2;
pub const nvmlPStates_enum_NVML_PSTATE_3: nvmlPStates_enum = 3;
pub const nvmlPStates_enum_NVML_PSTATE_4: nvmlPStates_enum = 4;
pub const nvmlPStates_enum_NVML_PSTATE_5: nvmlPStates_enum = 5;
pub const nvmlPStates_enum_NVML_PSTATE_6: nvmlPStates_enum = 6;
pub const nvmlPStates_enum_NVML_PSTATE_7: nvmlPStates_enum = 7;
pub const nvmlPStates_enum_NVML_PSTATE_8: nvmlPStates_enum = 8;
pub const nvmlPStates_enum_NVML_PSTATE_9: nvmlPStates_enum = 9;
pub const nvmlPStates_enum_NVML_PSTATE_10: nvmlPStates_enum = 10;
pub const nvmlPStates_enum_NVML_PSTATE_11: nvmlPStates_enum = 11;
pub const nvmlPStates_enum_NVML_PSTATE_12: nvmlPStates_enum = 12;
pub const nvmlPStates_enum_NVML_PSTATE_13: nvmlPStates_enum = 13;
pub const nvmlPStates_enum_NVML_PSTATE_14: nvmlPStates_enum = 14;
pub const nvmlPStates_enum_NVML_PSTATE_15: nvmlPStates_enum = 15;
pub const nvmlPStates_enum_NVML_PSTATE_UNKNOWN: nvmlPStates_enum = 32;
pub type nvmlPStates_enum = raw::c_uint;
pub use self::nvmlPStates_enum as nvmlPstates_t;
pub const nvmlGom_enum_NVML_GOM_ALL_ON: nvmlGom_enum = 0;
pub const nvmlGom_enum_NVML_GOM_COMPUTE: nvmlGom_enum = 1;
pub const nvmlGom_enum_NVML_GOM_LOW_DP: nvmlGom_enum = 2;
pub type nvmlGom_enum = raw::c_uint;
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
pub const nvmlInforomObject_enum_NVML_INFOROM_OEM: nvmlInforomObject_enum = 0;
pub const nvmlInforomObject_enum_NVML_INFOROM_ECC: nvmlInforomObject_enum = 1;
pub const nvmlInforomObject_enum_NVML_INFOROM_POWER: nvmlInforomObject_enum =
    2;
pub const nvmlInforomObject_enum_NVML_INFOROM_COUNT: nvmlInforomObject_enum =
    3;
pub type nvmlInforomObject_enum = raw::c_uint;
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
pub const nvmlReturn_enum_NVML_SUCCESS: nvmlReturn_enum = 0;
pub const nvmlReturn_enum_NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = 1;
pub const nvmlReturn_enum_NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = 2;
pub const nvmlReturn_enum_NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = 3;
pub const nvmlReturn_enum_NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = 4;
pub const nvmlReturn_enum_NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = 5;
pub const nvmlReturn_enum_NVML_ERROR_NOT_FOUND: nvmlReturn_enum = 6;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = 7;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = 8;
pub const nvmlReturn_enum_NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = 9;
pub const nvmlReturn_enum_NVML_ERROR_TIMEOUT: nvmlReturn_enum = 10;
pub const nvmlReturn_enum_NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = 11;
pub const nvmlReturn_enum_NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = 12;
pub const nvmlReturn_enum_NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = 13;
pub const nvmlReturn_enum_NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = 14;
pub const nvmlReturn_enum_NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = 15;
pub const nvmlReturn_enum_NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = 16;
pub const nvmlReturn_enum_NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = 17;
pub const nvmlReturn_enum_NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum
          =
    18;
pub const nvmlReturn_enum_NVML_ERROR_IN_USE: nvmlReturn_enum = 19;
pub const nvmlReturn_enum_NVML_ERROR_NO_DATA: nvmlReturn_enum = 20;
pub const nvmlReturn_enum_NVML_ERROR_UNKNOWN: nvmlReturn_enum = 999;
pub type nvmlReturn_enum = raw::c_uint;
pub use self::nvmlReturn_enum as nvmlReturn_t;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L1_CACHE:
          nvmlMemoryLocation_enum =
    0;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L2_CACHE:
          nvmlMemoryLocation_enum =
    1;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DEVICE_MEMORY:
          nvmlMemoryLocation_enum =
    2;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_REGISTER_FILE:
          nvmlMemoryLocation_enum =
    3;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_MEMORY:
          nvmlMemoryLocation_enum =
    4;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_SHM:
          nvmlMemoryLocation_enum =
    5;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_COUNT:
          nvmlMemoryLocation_enum =
    6;
pub type nvmlMemoryLocation_enum = raw::c_uint;
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
          nvmlPageRetirementCause_enum =
    0;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR:
          nvmlPageRetirementCause_enum =
    1;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_COUNT:
          nvmlPageRetirementCause_enum =
    2;
pub type nvmlPageRetirementCause_enum = raw::c_uint;
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS:
          nvmlRestrictedAPI_enum =
    0;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS:
          nvmlRestrictedAPI_enum =
    1;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_COUNT:
          nvmlRestrictedAPI_enum =
    2;
pub type nvmlRestrictedAPI_enum = raw::c_uint;
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
#[repr(C)]
#[derive(Debug)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: raw::c_uint,
    pub firmwareVersion: [raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_nvmlHwbcEntry_st() {
    assert_eq!(::std::mem::size_of::<nvmlHwbcEntry_st>() , 36usize , concat !
               ( "Size of: " , stringify ! ( nvmlHwbcEntry_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlHwbcEntry_st>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( nvmlHwbcEntry_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlHwbcEntry_st ) ) . hwbcId as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlHwbcEntry_st ) ,
                "::" , stringify ! ( hwbcId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlHwbcEntry_st ) ) . firmwareVersion as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlHwbcEntry_st ) ,
                "::" , stringify ! ( firmwareVersion ) ));
}
impl Clone for nvmlHwbcEntry_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
pub const nvmlFanState_enum_NVML_FAN_NORMAL: nvmlFanState_enum = 0;
pub const nvmlFanState_enum_NVML_FAN_FAILED: nvmlFanState_enum = 1;
pub type nvmlFanState_enum = raw::c_uint;
pub use self::nvmlFanState_enum as nvmlFanState_t;
pub const nvmlLedColor_enum_NVML_LED_COLOR_GREEN: nvmlLedColor_enum = 0;
pub const nvmlLedColor_enum_NVML_LED_COLOR_AMBER: nvmlLedColor_enum = 1;
pub type nvmlLedColor_enum = raw::c_uint;
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[repr(C)]
pub struct nvmlLedState_st {
    pub cause: [raw::c_char; 256usize],
    pub color: nvmlLedColor_t,
}
#[test]
fn bindgen_test_layout_nvmlLedState_st() {
    assert_eq!(::std::mem::size_of::<nvmlLedState_st>() , 260usize , concat !
               ( "Size of: " , stringify ! ( nvmlLedState_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlLedState_st>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( nvmlLedState_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlLedState_st ) ) . cause as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlLedState_st ) ,
                "::" , stringify ! ( cause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlLedState_st ) ) . color as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlLedState_st ) ,
                "::" , stringify ! ( color ) ));
}
pub type nvmlLedState_t = nvmlLedState_st;
#[repr(C)]
pub struct nvmlUnitInfo_st {
    pub name: [raw::c_char; 96usize],
    pub id: [raw::c_char; 96usize],
    pub serial: [raw::c_char; 96usize],
    pub firmwareVersion: [raw::c_char; 96usize],
}
#[test]
fn bindgen_test_layout_nvmlUnitInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitInfo_st>() , 384usize , concat !
               ( "Size of: " , stringify ! ( nvmlUnitInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUnitInfo_st>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( nvmlUnitInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . id as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . serial as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( serial ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . firmwareVersion as
                * const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( firmwareVersion ) ));
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[repr(C)]
pub struct nvmlPSUInfo_st {
    pub state: [raw::c_char; 256usize],
    pub current: raw::c_uint,
    pub voltage: raw::c_uint,
    pub power: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlPSUInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlPSUInfo_st>() , 268usize , concat ! (
               "Size of: " , stringify ! ( nvmlPSUInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlPSUInfo_st>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nvmlPSUInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . state as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . current as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . voltage as * const _
                as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( voltage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . power as * const _
                as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( power ) ));
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlUnitFanInfo_st {
    pub speed: raw::c_uint,
    pub state: nvmlFanState_t,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitFanInfo_st>() , 8usize , concat !
               ( "Size of: " , stringify ! ( nvmlUnitFanInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUnitFanInfo_st>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlUnitFanInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanInfo_st ) ) . speed as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanInfo_st ) ,
                "::" , stringify ! ( speed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanInfo_st ) ) . state as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanInfo_st ) ,
                "::" , stringify ! ( state ) ));
}
impl Clone for nvmlUnitFanInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlUnitFanSpeeds_st {
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    pub count: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanSpeeds_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitFanSpeeds_st>() , 196usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlUnitFanSpeeds_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlUnitFanSpeeds_st>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlUnitFanSpeeds_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanSpeeds_st ) ) . fans as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanSpeeds_st )
                , "::" , stringify ! ( fans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanSpeeds_st ) ) . count as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanSpeeds_st )
                , "::" , stringify ! ( count ) ));
}
impl Clone for nvmlUnitFanSpeeds_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Debug)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[repr(C)]
#[derive(Debug)]
pub struct nvmlEventData_st {
    pub device: nvmlDevice_t,
    pub eventType: raw::c_ulonglong,
    pub eventData: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEventData_st() {
    assert_eq!(::std::mem::size_of::<nvmlEventData_st>() , 24usize , concat !
               ( "Size of: " , stringify ! ( nvmlEventData_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlEventData_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nvmlEventData_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . device as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . eventType as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( eventType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . eventData as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( eventData ) ));
}
pub type nvmlEventData_t = nvmlEventData_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlAccountingStats_st {
    pub gpuUtilization: raw::c_uint,
    pub memoryUtilization: raw::c_uint,
    pub maxMemoryUsage: raw::c_ulonglong,
    pub time: raw::c_ulonglong,
    pub startTime: raw::c_ulonglong,
    pub isRunning: raw::c_uint,
    pub reserved: [raw::c_uint; 5usize],
}
#[test]
fn bindgen_test_layout_nvmlAccountingStats_st() {
    assert_eq!(::std::mem::size_of::<nvmlAccountingStats_st>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlAccountingStats_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlAccountingStats_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlAccountingStats_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                gpuUtilization as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( gpuUtilization ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                memoryUtilization as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( memoryUtilization ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                maxMemoryUsage as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( maxMemoryUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . startTime as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( startTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . isRunning as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( isRunning ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . reserved as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( reserved ) ));
}
impl Clone for nvmlAccountingStats_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
extern "C" {
    pub fn nvmlInit_v2() -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlShutdown() -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlErrorString(result: nvmlReturn_t) -> *const raw::c_char;
}
extern "C" {
    pub fn nvmlSystemGetDriverVersion(version: *mut raw::c_char,
                                      length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetNVMLVersion(version: *mut raw::c_char,
                                    length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetProcessName(pid: raw::c_uint, name: *mut raw::c_char,
                                    length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetCount(unitCount: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetHandleByIndex(index: raw::c_uint, unit: *mut nvmlUnit_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetUnitInfo(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetLedState(unit: nvmlUnit_t, state: *mut nvmlLedState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetPsuInfo(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetTemperature(unit: nvmlUnit_t, type_: raw::c_uint,
                                  temp: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetFanSpeedInfo(unit: nvmlUnit_t,
                                   fanSpeeds: *mut nvmlUnitFanSpeeds_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetDevices(unit: nvmlUnit_t, deviceCount: *mut raw::c_uint,
                              devices: *mut nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetHicVersion(hwbcCount: *mut raw::c_uint,
                                   hwbcEntries: *mut nvmlHwbcEntry_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCount_v2(deviceCount: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByIndex_v2(index: raw::c_uint,
                                         device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleBySerial(serial: *const raw::c_char,
                                       device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByUUID(uuid: *const raw::c_char,
                                     device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByPciBusId_v2(pciBusId: *const raw::c_char,
                                            device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetName(device: nvmlDevice_t, name: *mut raw::c_char,
                             length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBrand(device: nvmlDevice_t,
                              type_: *mut nvmlBrandType_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetIndex(device: nvmlDevice_t, index: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSerial(device: nvmlDevice_t, serial: *mut raw::c_char,
                               length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCpuAffinity(device: nvmlDevice_t,
                                    cpuSetSize: raw::c_uint,
                                    cpuSet: *mut raw::c_ulong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTopologyCommonAncestor(device1: nvmlDevice_t,
                                               device2: nvmlDevice_t,
                                               pathInfo:
                                                   *mut nvmlGpuTopologyLevel_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTopologyNearestGpus(device: nvmlDevice_t,
                                            level: nvmlGpuTopologyLevel_t,
                                            count: *mut raw::c_uint,
                                            deviceArray: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetTopologyGpuSet(cpuNumber: raw::c_uint,
                                       count: *mut raw::c_uint,
                                       deviceArray: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetP2PStatus(device1: nvmlDevice_t,
                                  device2: nvmlDevice_t,
                                  p2pIndex: nvmlGpuP2PCapsIndex_t,
                                  p2pStatus: *mut nvmlGpuP2PStatus_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetUUID(device: nvmlDevice_t, uuid: *mut raw::c_char,
                             length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMinorNumber(device: nvmlDevice_t,
                                    minorNumber: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBoardPartNumber(device: nvmlDevice_t,
                                        partNumber: *mut raw::c_char,
                                        length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomVersion(device: nvmlDevice_t,
                                       object: nvmlInforomObject_t,
                                       version: *mut raw::c_char,
                                       length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomImageVersion(device: nvmlDevice_t,
                                            version: *mut raw::c_char,
                                            length: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomConfigurationChecksum(device: nvmlDevice_t,
                                                     checksum:
                                                         *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceValidateInforom(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDisplayMode(device: nvmlDevice_t,
                                    display: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDisplayActive(device: nvmlDevice_t,
                                      isActive: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPersistenceMode(device: nvmlDevice_t,
                                        mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPciInfo_v2(device: nvmlDevice_t,
                                   pci: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxPcieLinkGeneration(device: nvmlDevice_t,
                                              maxLinkGen: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxPcieLinkWidth(device: nvmlDevice_t,
                                         maxLinkWidth: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrPcieLinkGeneration(device: nvmlDevice_t,
                                               currLinkGen: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrPcieLinkWidth(device: nvmlDevice_t,
                                          currLinkWidth: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPcieThroughput(device: nvmlDevice_t,
                                       counter: nvmlPcieUtilCounter_t,
                                       value: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPcieReplayCounter(device: nvmlDevice_t,
                                          value: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetClockInfo(device: nvmlDevice_t,
                                  type_: nvmlClockType_t,
                                  clock: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxClockInfo(device: nvmlDevice_t,
                                     type_: nvmlClockType_t,
                                     clock: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetApplicationsClock(device: nvmlDevice_t,
                                          clockType: nvmlClockType_t,
                                          clockMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDefaultApplicationsClock(device: nvmlDevice_t,
                                                 clockType: nvmlClockType_t,
                                                 clockMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetApplicationsClocks(device: nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetClock(device: nvmlDevice_t,
                              clockType: nvmlClockType_t,
                              clockId: nvmlClockId_t,
                              clockMHz: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxCustomerBoostClock(device: nvmlDevice_t,
                                              clockType: nvmlClockType_t,
                                              clockMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedMemoryClocks(device: nvmlDevice_t,
                                              count: *mut raw::c_uint,
                                              clocksMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedGraphicsClocks(device: nvmlDevice_t,
                                                memoryClockMHz: raw::c_uint,
                                                count: *mut raw::c_uint,
                                                clocksMHz: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                 isEnabled:
                                                     *mut nvmlEnableState_t,
                                                 defaultIsEnabled:
                                                     *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                 enabled: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                        enabled:
                                                            nvmlEnableState_t,
                                                        flags: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetFanSpeed(device: nvmlDevice_t,
                                 speed: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTemperature(device: nvmlDevice_t,
                                    sensorType: nvmlTemperatureSensors_t,
                                    temp: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTemperatureThreshold(device: nvmlDevice_t,
                                             thresholdType:
                                                 nvmlTemperatureThresholds_t,
                                             temp: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPerformanceState(device: nvmlDevice_t,
                                         pState: *mut nvmlPstates_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrentClocksThrottleReasons(device: nvmlDevice_t,
                                                     clocksThrottleReasons:
                                                         *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedClocksThrottleReasons(device: nvmlDevice_t,
                                                       supportedClocksThrottleReasons:
                                                           *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerState(device: nvmlDevice_t,
                                   pState: *mut nvmlPstates_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementMode(device: nvmlDevice_t,
                                            mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementLimit(device: nvmlDevice_t,
                                             limit: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementLimitConstraints(device: nvmlDevice_t,
                                                        minLimit:
                                                            *mut raw::c_uint,
                                                        maxLimit:
                                                            *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementDefaultLimit(device: nvmlDevice_t,
                                                    defaultLimit:
                                                        *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerUsage(device: nvmlDevice_t,
                                   power: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEnforcedPowerLimit(device: nvmlDevice_t,
                                           limit: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetGpuOperationMode(device: nvmlDevice_t,
                                         current: *mut nvmlGpuOperationMode_t,
                                         pending: *mut nvmlGpuOperationMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMemoryInfo(device: nvmlDevice_t,
                                   memory: *mut nvmlMemory_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetComputeMode(device: nvmlDevice_t,
                                    mode: *mut nvmlComputeMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEccMode(device: nvmlDevice_t,
                                current: *mut nvmlEnableState_t,
                                pending: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBoardId(device: nvmlDevice_t,
                                boardId: *mut raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMultiGpuBoard(device: nvmlDevice_t,
                                      multiGpuBool: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTotalEccErrors(device: nvmlDevice_t,
                                       errorType: nvmlMemoryErrorType_t,
                                       counterType: nvmlEccCounterType_t,
                                       eccCounts: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDetailedEccErrors(device: nvmlDevice_t,
                                          errorType: nvmlMemoryErrorType_t,
                                          counterType: nvmlEccCounterType_t,
                                          eccCounts:
                                              *mut nvmlEccErrorCounts_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMemoryErrorCounter(device: nvmlDevice_t,
                                           errorType: nvmlMemoryErrorType_t,
                                           counterType: nvmlEccCounterType_t,
                                           locationType: nvmlMemoryLocation_t,
                                           count: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetUtilizationRates(device: nvmlDevice_t,
                                         utilization: *mut nvmlUtilization_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEncoderUtilization(device: nvmlDevice_t,
                                           utilization: *mut raw::c_uint,
                                           samplingPeriodUs: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDecoderUtilization(device: nvmlDevice_t,
                                           utilization: *mut raw::c_uint,
                                           samplingPeriodUs: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDriverModel(device: nvmlDevice_t,
                                    current: *mut nvmlDriverModel_t,
                                    pending: *mut nvmlDriverModel_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetVbiosVersion(device: nvmlDevice_t,
                                     version: *mut raw::c_char,
                                     length: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBridgeChipInfo(device: nvmlDevice_t,
                                       bridgeHierarchy:
                                           *mut nvmlBridgeChipHierarchy_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetComputeRunningProcesses(device: nvmlDevice_t,
                                                infoCount: *mut raw::c_uint,
                                                infos: *mut nvmlProcessInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetGraphicsRunningProcesses(device: nvmlDevice_t,
                                                 infoCount: *mut raw::c_uint,
                                                 infos:
                                                     *mut nvmlProcessInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceOnSameBoard(device1: nvmlDevice_t, device2: nvmlDevice_t,
                                 onSameBoard: *mut raw::c_int)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAPIRestriction(device: nvmlDevice_t,
                                       apiType: nvmlRestrictedAPI_t,
                                       isRestricted: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
#[cfg(feature = "nightly")]
extern "C" {
    pub fn nvmlDeviceGetSamples(device: nvmlDevice_t,
                                type_: nvmlSamplingType_t,
                                lastSeenTimeStamp: raw::c_ulonglong,
                                sampleValType: *mut nvmlValueType_t,
                                sampleCount: *mut raw::c_uint,
                                samples: *mut nvmlSample_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBAR1MemoryInfo(device: nvmlDevice_t,
                                       bar1Memory: *mut nvmlBAR1Memory_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetViolationStatus(device: nvmlDevice_t,
                                        perfPolicyType: nvmlPerfPolicyType_t,
                                        violTime: *mut nvmlViolationTime_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingMode(device: nvmlDevice_t,
                                       mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingStats(device: nvmlDevice_t,
                                        pid: raw::c_uint,
                                        stats: *mut nvmlAccountingStats_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingPids(device: nvmlDevice_t,
                                       count: *mut raw::c_uint,
                                       pids: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingBufferSize(device: nvmlDevice_t,
                                             bufferSize: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetRetiredPages(device: nvmlDevice_t,
                                     cause: nvmlPageRetirementCause_t,
                                     pageCount: *mut raw::c_uint,
                                     addresses: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetRetiredPagesPendingStatus(device: nvmlDevice_t,
                                                  isPending:
                                                      *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitSetLedState(unit: nvmlUnit_t, color: nvmlLedColor_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetPersistenceMode(device: nvmlDevice_t,
                                        mode: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetComputeMode(device: nvmlDevice_t,
                                    mode: nvmlComputeMode_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetEccMode(device: nvmlDevice_t, ecc: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearEccErrorCounts(device: nvmlDevice_t,
                                         counterType: nvmlEccCounterType_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetDriverModel(device: nvmlDevice_t,
                                    driverModel: nvmlDriverModel_t,
                                    flags: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetApplicationsClocks(device: nvmlDevice_t,
                                           memClockMHz: raw::c_uint,
                                           graphicsClockMHz: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetPowerManagementLimit(device: nvmlDevice_t,
                                             limit: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetGpuOperationMode(device: nvmlDevice_t,
                                         mode: nvmlGpuOperationMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAPIRestriction(device: nvmlDevice_t,
                                       apiType: nvmlRestrictedAPI_t,
                                       isRestricted: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAccountingMode(device: nvmlDevice_t,
                                       mode: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearAccountingPids(device: nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkState(device: nvmlDevice_t, link: raw::c_uint,
                                    isActive: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkVersion(device: nvmlDevice_t, link: raw::c_uint,
                                      version: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkCapability(device: nvmlDevice_t,
                                         link: raw::c_uint,
                                         capability: nvmlNvLinkCapability_t,
                                         capResult: *mut raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkRemotePciInfo(device: nvmlDevice_t,
                                            link: raw::c_uint,
                                            pci: *mut nvmlPciInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkErrorCounter(device: nvmlDevice_t,
                                           link: raw::c_uint,
                                           counter: nvmlNvLinkErrorCounter_t,
                                           counterValue:
                                               *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetNvLinkErrorCounters(device: nvmlDevice_t,
                                              link: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetNvLinkUtilizationControl(device: nvmlDevice_t,
                                                 link: raw::c_uint,
                                                 counter: raw::c_uint,
                                                 control:
                                                     *mut nvmlNvLinkUtilizationControl_t,
                                                 reset: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkUtilizationControl(device: nvmlDevice_t,
                                                 link: raw::c_uint,
                                                 counter: raw::c_uint,
                                                 control:
                                                     *mut nvmlNvLinkUtilizationControl_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                 link: raw::c_uint,
                                                 counter: raw::c_uint,
                                                 rxcounter:
                                                     *mut raw::c_ulonglong,
                                                 txcounter:
                                                     *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceFreezeNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                    link: raw::c_uint,
                                                    counter: raw::c_uint,
                                                    freeze: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                   link: raw::c_uint,
                                                   counter: raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetCreate(set: *mut nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceRegisterEvents(device: nvmlDevice_t,
                                    eventTypes: raw::c_ulonglong,
                                    set: nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedEventTypes(device: nvmlDevice_t,
                                            eventTypes: *mut raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetWait(set: nvmlEventSet_t, data: *mut nvmlEventData_t,
                            timeoutms: raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetFree(set: nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceModifyDrainState(pciInfo: *mut nvmlPciInfo_t,
                                      newState: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceQueryDrainState(pciInfo: *mut nvmlPciInfo_t,
                                     currentState: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceRemoveGpu(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceDiscoverGpus(pciInfo: *mut nvmlPciInfo_t)
     -> nvmlReturn_t;
}
