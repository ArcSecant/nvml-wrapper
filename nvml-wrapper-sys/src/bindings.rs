/* automatically generated by rust-bindgen 0.56.0 */

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
use std::os::raw;

pub const NVML_API_VERSION: u32 = 11;
pub const NVML_API_VERSION_STR: &'static [u8; 3usize] = b"11\0";
pub const NVML_VALUE_NOT_AVAILABLE: i32 = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: u32 = 32;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE: u32 = 16;
pub const NVML_DEVICE_PCI_BUS_ID_LEGACY_FMT: &'static [u8; 17usize] = b"%04X:%02X:%02X.0\0";
pub const NVML_DEVICE_PCI_BUS_ID_FMT: &'static [u8; 17usize] = b"%08X:%02X:%02X.0\0";
pub const NVML_NVLINK_MAX_LINKS: u32 = 12;
pub const NVML_MAX_PHYSICAL_BRIDGE: u32 = 128;
pub const nvmlFlagDefault: u32 = 0;
pub const nvmlFlagForce: u32 = 1;
pub const NVML_GRID_LICENSE_BUFFER_SIZE: u32 = 128;
pub const NVML_VGPU_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_GRID_LICENSE_FEATURE_MAX_COUNT: u32 = 3;
pub const INVALID_GPU_INSTANCE_PROFILE_ID: u32 = 4294967295;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_DEVICE_ARCH_KEPLER: u32 = 2;
pub const NVML_DEVICE_ARCH_MAXWELL: u32 = 3;
pub const NVML_DEVICE_ARCH_PASCAL: u32 = 4;
pub const NVML_DEVICE_ARCH_VOLTA: u32 = 5;
pub const NVML_DEVICE_ARCH_TURING: u32 = 6;
pub const NVML_DEVICE_ARCH_AMPERE: u32 = 7;
pub const NVML_DEVICE_ARCH_UNKNOWN: u32 = 4294967295;
pub mod field_id {
    pub const NVML_FI_DEV_ECC_CURRENT: u32 = 1;
    pub const NVML_FI_DEV_ECC_PENDING: u32 = 2;
    pub const NVML_FI_DEV_ECC_SBE_VOL_TOTAL: u32 = 3;
    pub const NVML_FI_DEV_ECC_DBE_VOL_TOTAL: u32 = 4;
    pub const NVML_FI_DEV_ECC_SBE_AGG_TOTAL: u32 = 5;
    pub const NVML_FI_DEV_ECC_DBE_AGG_TOTAL: u32 = 6;
    pub const NVML_FI_DEV_ECC_SBE_VOL_L1: u32 = 7;
    pub const NVML_FI_DEV_ECC_DBE_VOL_L1: u32 = 8;
    pub const NVML_FI_DEV_ECC_SBE_VOL_L2: u32 = 9;
    pub const NVML_FI_DEV_ECC_DBE_VOL_L2: u32 = 10;
    pub const NVML_FI_DEV_ECC_SBE_VOL_DEV: u32 = 11;
    pub const NVML_FI_DEV_ECC_DBE_VOL_DEV: u32 = 12;
    pub const NVML_FI_DEV_ECC_SBE_VOL_REG: u32 = 13;
    pub const NVML_FI_DEV_ECC_DBE_VOL_REG: u32 = 14;
    pub const NVML_FI_DEV_ECC_SBE_VOL_TEX: u32 = 15;
    pub const NVML_FI_DEV_ECC_DBE_VOL_TEX: u32 = 16;
    pub const NVML_FI_DEV_ECC_DBE_VOL_CBU: u32 = 17;
    pub const NVML_FI_DEV_ECC_SBE_AGG_L1: u32 = 18;
    pub const NVML_FI_DEV_ECC_DBE_AGG_L1: u32 = 19;
    pub const NVML_FI_DEV_ECC_SBE_AGG_L2: u32 = 20;
    pub const NVML_FI_DEV_ECC_DBE_AGG_L2: u32 = 21;
    pub const NVML_FI_DEV_ECC_SBE_AGG_DEV: u32 = 22;
    pub const NVML_FI_DEV_ECC_DBE_AGG_DEV: u32 = 23;
    pub const NVML_FI_DEV_ECC_SBE_AGG_REG: u32 = 24;
    pub const NVML_FI_DEV_ECC_DBE_AGG_REG: u32 = 25;
    pub const NVML_FI_DEV_ECC_SBE_AGG_TEX: u32 = 26;
    pub const NVML_FI_DEV_ECC_DBE_AGG_TEX: u32 = 27;
    pub const NVML_FI_DEV_ECC_DBE_AGG_CBU: u32 = 28;
    pub const NVML_FI_DEV_RETIRED_SBE: u32 = 29;
    pub const NVML_FI_DEV_RETIRED_DBE: u32 = 30;
    pub const NVML_FI_DEV_RETIRED_PENDING: u32 = 31;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0: u32 = 32;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1: u32 = 33;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2: u32 = 34;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3: u32 = 35;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4: u32 = 36;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5: u32 = 37;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL: u32 = 38;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0: u32 = 39;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1: u32 = 40;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2: u32 = 41;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3: u32 = 42;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4: u32 = 43;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5: u32 = 44;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL: u32 = 45;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0: u32 = 46;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1: u32 = 47;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2: u32 = 48;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3: u32 = 49;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4: u32 = 50;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5: u32 = 51;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL: u32 = 52;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0: u32 = 53;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1: u32 = 54;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2: u32 = 55;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3: u32 = 56;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4: u32 = 57;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5: u32 = 58;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL: u32 = 59;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0: u32 = 60;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1: u32 = 61;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2: u32 = 62;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3: u32 = 63;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4: u32 = 64;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5: u32 = 65;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL: u32 = 66;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0: u32 = 67;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1: u32 = 68;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2: u32 = 69;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3: u32 = 70;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4: u32 = 71;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5: u32 = 72;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL: u32 = 73;
    pub const NVML_FI_DEV_PERF_POLICY_POWER: u32 = 74;
    pub const NVML_FI_DEV_PERF_POLICY_THERMAL: u32 = 75;
    pub const NVML_FI_DEV_PERF_POLICY_SYNC_BOOST: u32 = 76;
    pub const NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT: u32 = 77;
    pub const NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION: u32 = 78;
    pub const NVML_FI_DEV_PERF_POLICY_RELIABILITY: u32 = 79;
    pub const NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS: u32 = 80;
    pub const NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS: u32 = 81;
    pub const NVML_FI_DEV_MEMORY_TEMP: u32 = 82;
    pub const NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION: u32 = 83;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L0: u32 = 84;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L1: u32 = 85;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L2: u32 = 86;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L3: u32 = 87;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L4: u32 = 88;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L5: u32 = 89;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_COMMON: u32 = 90;
    pub const NVML_FI_DEV_NVLINK_LINK_COUNT: u32 = 91;
    pub const NVML_FI_DEV_RETIRED_PENDING_SBE: u32 = 92;
    pub const NVML_FI_DEV_RETIRED_PENDING_DBE: u32 = 93;
    pub const NVML_FI_DEV_PCIE_REPLAY_COUNTER: u32 = 94;
    pub const NVML_FI_DEV_PCIE_REPLAY_ROLLOVER_COUNTER: u32 = 95;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L6: u32 = 96;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L7: u32 = 97;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L8: u32 = 98;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L9: u32 = 99;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L10: u32 = 100;
    pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L11: u32 = 101;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L6: u32 = 102;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L7: u32 = 103;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L8: u32 = 104;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L9: u32 = 105;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L10: u32 = 106;
    pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L11: u32 = 107;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L6: u32 = 108;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L7: u32 = 109;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L8: u32 = 110;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L9: u32 = 111;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L10: u32 = 112;
    pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L11: u32 = 113;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L6: u32 = 114;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L7: u32 = 115;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L8: u32 = 116;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L9: u32 = 117;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L10: u32 = 118;
    pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L11: u32 = 119;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L6: u32 = 120;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L7: u32 = 121;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L8: u32 = 122;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L9: u32 = 123;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L10: u32 = 124;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L11: u32 = 125;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L6: u32 = 126;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L7: u32 = 127;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L8: u32 = 128;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L9: u32 = 129;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L10: u32 = 130;
    pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L11: u32 = 131;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L6: u32 = 132;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L7: u32 = 133;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L8: u32 = 134;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L9: u32 = 135;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L10: u32 = 136;
    pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L11: u32 = 137;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_TX: u32 = 138;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_DATA_RX: u32 = 139;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_TX: u32 = 140;
    pub const NVML_FI_DEV_NVLINK_THROUGHPUT_RAW_RX: u32 = 141;
    pub const NVML_FI_DEV_REMAPPED_COR: u32 = 142;
    pub const NVML_FI_DEV_REMAPPED_UNC: u32 = 143;
    pub const NVML_FI_DEV_REMAPPED_PENDING: u32 = 144;
    pub const NVML_FI_DEV_REMAPPED_FAILURE: u32 = 145;
    pub const NVML_FI_DEV_NVLINK_REMOTE_NVLINK_ID: u32 = 146;
    pub const NVML_FI_MAX: u32 = 147;
}
pub const nvmlEventTypeSingleBitEccError: u32 = 1;
pub const nvmlEventTypeDoubleBitEccError: u32 = 2;
pub const nvmlEventTypePState: u32 = 4;
pub const nvmlEventTypeXidCriticalError: u32 = 8;
pub const nvmlEventTypeClock: u32 = 16;
pub const nvmlEventTypePowerSourceChange: u32 = 128;
pub const nvmlEventMigConfigChange: u32 = 256;
pub const nvmlEventTypeNone: u32 = 0;
pub const nvmlEventTypeAll: u32 = 415;
pub const nvmlClocksThrottleReasonGpuIdle: u32 = 1;
pub const nvmlClocksThrottleReasonApplicationsClocksSetting: u32 = 2;
pub const nvmlClocksThrottleReasonUserDefinedClocks: u32 = 2;
pub const nvmlClocksThrottleReasonSwPowerCap: u32 = 4;
pub const nvmlClocksThrottleReasonHwSlowdown: u32 = 8;
pub const nvmlClocksThrottleReasonSyncBoost: u32 = 16;
pub const nvmlClocksThrottleReasonSwThermalSlowdown: u32 = 32;
pub const nvmlClocksThrottleReasonHwThermalSlowdown: u32 = 64;
pub const nvmlClocksThrottleReasonHwPowerBrakeSlowdown: u32 = 128;
pub const nvmlClocksThrottleReasonDisplayClockSetting: u32 = 256;
pub const nvmlClocksThrottleReasonNone: u32 = 0;
pub const NVML_NVFBC_SESSION_FLAG_DIFFMAP_ENABLED: u32 = 1;
pub const NVML_NVFBC_SESSION_FLAG_CLASSIFICATIONMAP_ENABLED: u32 = 2;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_NO_WAIT: u32 = 4;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_INFINITE: u32 = 8;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_TIMEOUT: u32 = 16;
pub const NVML_INIT_FLAG_NO_GPUS: u32 = 1;
pub const NVML_INIT_FLAG_NO_ATTACH: u32 = 2;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: u32 = 16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_UUID_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_DEVICE_NAME_V2_BUFFER_SIZE: u32 = 96;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: u32 = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: u32 = 32;
pub const NVML_AFFINITY_SCOPE_NODE: u32 = 0;
pub const NVML_AFFINITY_SCOPE_SOCKET: u32 = 1;
pub const NVML_DEVICE_MIG_DISABLE: u32 = 0;
pub const NVML_DEVICE_MIG_ENABLE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_GPU_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_GPU_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_GPU_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_GPU_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_GPU_INSTANCE_PROFILE_8_SLICE: u32 = 5;
pub const NVML_GPU_INSTANCE_PROFILE_COUNT: u32 = 6;
pub const NVML_COMPUTE_INSTANCE_PROFILE_1_SLICE: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_PROFILE_2_SLICE: u32 = 1;
pub const NVML_COMPUTE_INSTANCE_PROFILE_3_SLICE: u32 = 2;
pub const NVML_COMPUTE_INSTANCE_PROFILE_4_SLICE: u32 = 3;
pub const NVML_COMPUTE_INSTANCE_PROFILE_7_SLICE: u32 = 4;
pub const NVML_COMPUTE_INSTANCE_PROFILE_8_SLICE: u32 = 5;
pub const NVML_COMPUTE_INSTANCE_PROFILE_COUNT: u32 = 6;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_SHARED: u32 = 0;
pub const NVML_COMPUTE_INSTANCE_ENGINE_PROFILE_COUNT: u32 = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlPciInfo_st {
    pub busIdLegacy: [raw::c_char; 16usize],
    pub domain: raw::c_uint,
    pub bus: raw::c_uint,
    pub device: raw::c_uint,
    pub pciDeviceId: raw::c_uint,
    pub pciSubSystemId: raw::c_uint,
    pub busId: [raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_nvmlPciInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlPciInfo_st>(),
        68usize,
        concat!("Size of: ", stringify!(nvmlPciInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlPciInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlPciInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).busIdLegacy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(busIdLegacy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).domain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).bus as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).device as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).pciDeviceId as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(pciDeviceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).pciSubSystemId as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(pciSubSystemId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).busId as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(busId)
        )
    );
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEccErrorCounts_st {
    pub l1Cache: raw::c_ulonglong,
    pub l2Cache: raw::c_ulonglong,
    pub deviceMemory: raw::c_ulonglong,
    pub registerFile: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEccErrorCounts_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlEccErrorCounts_st>(),
        32usize,
        concat!("Size of: ", stringify!(nvmlEccErrorCounts_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlEccErrorCounts_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlEccErrorCounts_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEccErrorCounts_st>())).l1Cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEccErrorCounts_st),
            "::",
            stringify!(l1Cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEccErrorCounts_st>())).l2Cache as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEccErrorCounts_st),
            "::",
            stringify!(l2Cache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEccErrorCounts_st>())).deviceMemory as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEccErrorCounts_st),
            "::",
            stringify!(deviceMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEccErrorCounts_st>())).registerFile as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEccErrorCounts_st),
            "::",
            stringify!(registerFile)
        )
    );
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUtilization_st {
    pub gpu: raw::c_uint,
    pub memory: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUtilization_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlUtilization_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlUtilization_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlUtilization_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlUtilization_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUtilization_st>())).gpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUtilization_st),
            "::",
            stringify!(gpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUtilization_st>())).memory as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUtilization_st),
            "::",
            stringify!(memory)
        )
    );
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlMemory_st {
    pub total: raw::c_ulonglong,
    pub free: raw::c_ulonglong,
    pub used: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlMemory_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlMemory_st>(),
        24usize,
        concat!("Size of: ", stringify!(nvmlMemory_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlMemory_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlMemory_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlMemory_st>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlMemory_st),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlMemory_st>())).free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlMemory_st),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlMemory_st>())).used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlMemory_st),
            "::",
            stringify!(used)
        )
    );
}
pub type nvmlMemory_t = nvmlMemory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBAR1Memory_st {
    pub bar1Total: raw::c_ulonglong,
    pub bar1Free: raw::c_ulonglong,
    pub bar1Used: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlBAR1Memory_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlBAR1Memory_st>(),
        24usize,
        concat!("Size of: ", stringify!(nvmlBAR1Memory_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlBAR1Memory_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlBAR1Memory_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBAR1Memory_st>())).bar1Total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBAR1Memory_st),
            "::",
            stringify!(bar1Total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBAR1Memory_st>())).bar1Free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBAR1Memory_st),
            "::",
            stringify!(bar1Free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBAR1Memory_st>())).bar1Used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBAR1Memory_st),
            "::",
            stringify!(bar1Used)
        )
    );
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessInfo_st {
    pub pid: raw::c_uint,
    pub usedGpuMemory: raw::c_ulonglong,
    pub gpuInstanceId: raw::c_uint,
    pub computeInstanceId: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlProcessInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlProcessInfo_st>(),
        24usize,
        concat!("Size of: ", stringify!(nvmlProcessInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlProcessInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlProcessInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlProcessInfo_st>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessInfo_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessInfo_st>())).usedGpuMemory as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessInfo_st),
            "::",
            stringify!(usedGpuMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessInfo_st>())).gpuInstanceId as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessInfo_st),
            "::",
            stringify!(gpuInstanceId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessInfo_st>())).computeInstanceId as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessInfo_st),
            "::",
            stringify!(computeInstanceId)
        )
    );
}
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDeviceAttributes_st {
    pub multiprocessorCount: raw::c_uint,
    pub sharedCopyEngineCount: raw::c_uint,
    pub sharedDecoderCount: raw::c_uint,
    pub sharedEncoderCount: raw::c_uint,
    pub sharedJpegCount: raw::c_uint,
    pub sharedOfaCount: raw::c_uint,
    pub gpuInstanceSliceCount: raw::c_uint,
    pub computeInstanceSliceCount: raw::c_uint,
    pub memorySizeMB: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlDeviceAttributes_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlDeviceAttributes_st>(),
        40usize,
        concat!("Size of: ", stringify!(nvmlDeviceAttributes_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlDeviceAttributes_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlDeviceAttributes_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).multiprocessorCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(multiprocessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).sharedCopyEngineCount as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(sharedCopyEngineCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).sharedDecoderCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(sharedDecoderCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).sharedEncoderCount as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(sharedEncoderCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).sharedJpegCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(sharedJpegCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).sharedOfaCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(sharedOfaCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).gpuInstanceSliceCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(gpuInstanceSliceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).computeInstanceSliceCount
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(computeInstanceSliceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlDeviceAttributes_st>())).memorySizeMB as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlDeviceAttributes_st),
            "::",
            stringify!(memorySizeMB)
        )
    );
}
pub type nvmlDeviceAttributes_t = nvmlDeviceAttributes_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlRowRemapperHistogramValues_st {
    pub max: raw::c_uint,
    pub high: raw::c_uint,
    pub partial: raw::c_uint,
    pub low: raw::c_uint,
    pub none: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlRowRemapperHistogramValues_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlRowRemapperHistogramValues_st>(),
        20usize,
        concat!("Size of: ", stringify!(nvmlRowRemapperHistogramValues_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlRowRemapperHistogramValues_st>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(nvmlRowRemapperHistogramValues_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlRowRemapperHistogramValues_st>())).max as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlRowRemapperHistogramValues_st),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlRowRemapperHistogramValues_st>())).high as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlRowRemapperHistogramValues_st),
            "::",
            stringify!(high)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlRowRemapperHistogramValues_st>())).partial as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlRowRemapperHistogramValues_st),
            "::",
            stringify!(partial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlRowRemapperHistogramValues_st>())).low as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlRowRemapperHistogramValues_st),
            "::",
            stringify!(low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlRowRemapperHistogramValues_st>())).none as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlRowRemapperHistogramValues_st),
            "::",
            stringify!(none)
        )
    );
}
pub type nvmlRowRemapperHistogramValues_t = nvmlRowRemapperHistogramValues_st;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_PLX: nvmlBridgeChipType_enum = 0;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_BRO4: nvmlBridgeChipType_enum = 1;
pub type nvmlBridgeChipType_enum = raw::c_uint;
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_CYCLES:
    nvmlNvLinkUtilizationCountUnits_enum = 0;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_PACKETS:
    nvmlNvLinkUtilizationCountUnits_enum = 1;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_BYTES:
    nvmlNvLinkUtilizationCountUnits_enum = 2;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_RESERVED:
    nvmlNvLinkUtilizationCountUnits_enum = 3;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_COUNT:
    nvmlNvLinkUtilizationCountUnits_enum = 4;
pub type nvmlNvLinkUtilizationCountUnits_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountUnits_enum as nvmlNvLinkUtilizationCountUnits_t;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NOP:
    nvmlNvLinkUtilizationCountPktTypes_enum = 1;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_READ:
    nvmlNvLinkUtilizationCountPktTypes_enum = 2;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_WRITE:
    nvmlNvLinkUtilizationCountPktTypes_enum = 4;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 8;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NRATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 16;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_FLUSH:
    nvmlNvLinkUtilizationCountPktTypes_enum = 32;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 64;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 128;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_ALL:
    nvmlNvLinkUtilizationCountPktTypes_enum = 255;
pub type nvmlNvLinkUtilizationCountPktTypes_enum = raw::c_uint;
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as nvmlNvLinkUtilizationCountPktTypes_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
#[test]
fn bindgen_test_layout_nvmlNvLinkUtilizationControl_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlNvLinkUtilizationControl_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlNvLinkUtilizationControl_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlNvLinkUtilizationControl_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlNvLinkUtilizationControl_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlNvLinkUtilizationControl_st>())).units as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlNvLinkUtilizationControl_st),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlNvLinkUtilizationControl_st>())).pktfilter as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlNvLinkUtilizationControl_st),
            "::",
            stringify!(pktfilter)
        )
    );
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_SUPPORTED: nvmlNvLinkCapability_enum = 0;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ACCESS: nvmlNvLinkCapability_enum = 1;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_ATOMICS: nvmlNvLinkCapability_enum = 2;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ATOMICS: nvmlNvLinkCapability_enum = 3;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SLI_BRIDGE: nvmlNvLinkCapability_enum = 4;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_VALID: nvmlNvLinkCapability_enum = 5;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_COUNT: nvmlNvLinkCapability_enum = 6;
pub type nvmlNvLinkCapability_enum = raw::c_uint;
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_REPLAY: nvmlNvLinkErrorCounter_enum = 0;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_RECOVERY: nvmlNvLinkErrorCounter_enum =
    1;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_FLIT: nvmlNvLinkErrorCounter_enum =
    2;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_DATA: nvmlNvLinkErrorCounter_enum =
    3;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_COUNT: nvmlNvLinkErrorCounter_enum = 4;
pub type nvmlNvLinkErrorCounter_enum = raw::c_uint;
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = 0;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = 10;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = 20;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = 30;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_NODE: nvmlGpuLevel_enum = 40;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = 50;
pub type nvmlGpuLevel_enum = raw::c_uint;
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = 0;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED: nvmlGpuP2PStatus_enum = 1;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_GPU_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 2;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED: nvmlGpuP2PStatus_enum =
    3;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_DISABLED_BY_REGKEY: nvmlGpuP2PStatus_enum = 4;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 5;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum = 6;
pub type nvmlGpuP2PStatus_enum = raw::c_uint;
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_READ: nvmlGpuP2PCapsIndex_enum = 0;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_WRITE: nvmlGpuP2PCapsIndex_enum = 1;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_NVLINK: nvmlGpuP2PCapsIndex_enum = 2;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_ATOMICS: nvmlGpuP2PCapsIndex_enum = 3;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_PROP: nvmlGpuP2PCapsIndex_enum = 4;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_UNKNOWN: nvmlGpuP2PCapsIndex_enum = 5;
pub type nvmlGpuP2PCapsIndex_enum = raw::c_uint;
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBridgeChipInfo_st {
    pub type_: nvmlBridgeChipType_t,
    pub fwVersion: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlBridgeChipInfo_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlBridgeChipInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlBridgeChipInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlBridgeChipInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBridgeChipInfo_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBridgeChipInfo_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBridgeChipInfo_st>())).fwVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBridgeChipInfo_st),
            "::",
            stringify!(fwVersion)
        )
    );
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBridgeChipHierarchy_st {
    pub bridgeCount: raw::c_uchar,
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipHierarchy_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlBridgeChipHierarchy_st>(),
        1028usize,
        concat!("Size of: ", stringify!(nvmlBridgeChipHierarchy_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlBridgeChipHierarchy_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlBridgeChipHierarchy_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlBridgeChipHierarchy_st>())).bridgeCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBridgeChipHierarchy_st),
            "::",
            stringify!(bridgeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlBridgeChipHierarchy_st>())).bridgeChipInfo as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBridgeChipHierarchy_st),
            "::",
            stringify!(bridgeChipInfo)
        )
    );
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
pub const nvmlSamplingType_enum_NVML_TOTAL_POWER_SAMPLES: nvmlSamplingType_enum = 0;
pub const nvmlSamplingType_enum_NVML_GPU_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 1;
pub const nvmlSamplingType_enum_NVML_MEMORY_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 2;
pub const nvmlSamplingType_enum_NVML_ENC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 3;
pub const nvmlSamplingType_enum_NVML_DEC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 4;
pub const nvmlSamplingType_enum_NVML_PROCESSOR_CLK_SAMPLES: nvmlSamplingType_enum = 5;
pub const nvmlSamplingType_enum_NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum = 6;
pub const nvmlSamplingType_enum_NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum = 7;
pub type nvmlSamplingType_enum = raw::c_uint;
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_TX_BYTES: nvmlPcieUtilCounter_enum = 0;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_RX_BYTES: nvmlPcieUtilCounter_enum = 1;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_COUNT: nvmlPcieUtilCounter_enum = 2;
pub type nvmlPcieUtilCounter_enum = raw::c_uint;
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = 0;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum = 1;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum = 2;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG_LONG: nvmlValueType_enum = 3;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_SIGNED_LONG_LONG: nvmlValueType_enum = 4;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = 5;
pub type nvmlValueType_enum = raw::c_uint;
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlValue_st {
    pub dVal: f64,
    pub uiVal: raw::c_uint,
    pub ulVal: raw::c_ulong,
    pub ullVal: raw::c_ulonglong,
    pub sllVal: raw::c_longlong,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_nvmlValue_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlValue_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlValue_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlValue_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlValue_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).dVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(dVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).uiVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(uiVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).ulVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(ulVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).ullVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(ullVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).sllVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(sllVal)
        )
    );
}
pub type nvmlValue_t = nvmlValue_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlSample_st {
    pub timeStamp: raw::c_ulonglong,
    pub sampleValue: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlSample_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlSample_st>(),
        16usize,
        concat!("Size of: ", stringify!(nvmlSample_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlSample_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlSample_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlSample_st>())).timeStamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlSample_st),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlSample_st>())).sampleValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlSample_st),
            "::",
            stringify!(sampleValue)
        )
    );
}
pub type nvmlSample_t = nvmlSample_st;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_POWER: nvmlPerfPolicyType_enum = 0;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_THERMAL: nvmlPerfPolicyType_enum = 1;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_SYNC_BOOST: nvmlPerfPolicyType_enum = 2;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_BOARD_LIMIT: nvmlPerfPolicyType_enum = 3;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_LOW_UTILIZATION: nvmlPerfPolicyType_enum = 4;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_RELIABILITY: nvmlPerfPolicyType_enum = 5;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_APP_CLOCKS: nvmlPerfPolicyType_enum = 10;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_BASE_CLOCKS: nvmlPerfPolicyType_enum = 11;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_COUNT: nvmlPerfPolicyType_enum = 12;
pub type nvmlPerfPolicyType_enum = raw::c_uint;
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlViolationTime_st {
    pub referenceTime: raw::c_ulonglong,
    pub violationTime: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlViolationTime_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlViolationTime_st>(),
        16usize,
        concat!("Size of: ", stringify!(nvmlViolationTime_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlViolationTime_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlViolationTime_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlViolationTime_st>())).referenceTime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlViolationTime_st),
            "::",
            stringify!(referenceTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlViolationTime_st>())).violationTime as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlViolationTime_st),
            "::",
            stringify!(violationTime)
        )
    );
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
pub const nvmlEnableState_enum_NVML_FEATURE_DISABLED: nvmlEnableState_enum = 0;
pub const nvmlEnableState_enum_NVML_FEATURE_ENABLED: nvmlEnableState_enum = 1;
pub type nvmlEnableState_enum = raw::c_uint;
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
pub const nvmlBrandType_enum_NVML_BRAND_UNKNOWN: nvmlBrandType_enum = 0;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO: nvmlBrandType_enum = 1;
pub const nvmlBrandType_enum_NVML_BRAND_TESLA: nvmlBrandType_enum = 2;
pub const nvmlBrandType_enum_NVML_BRAND_NVS: nvmlBrandType_enum = 3;
pub const nvmlBrandType_enum_NVML_BRAND_GRID: nvmlBrandType_enum = 4;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE: nvmlBrandType_enum = 5;
pub const nvmlBrandType_enum_NVML_BRAND_TITAN: nvmlBrandType_enum = 6;
pub const nvmlBrandType_enum_NVML_BRAND_COUNT: nvmlBrandType_enum = 7;
pub type nvmlBrandType_enum = raw::c_uint;
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SHUTDOWN:
    nvmlTemperatureThresholds_enum = 0;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SLOWDOWN:
    nvmlTemperatureThresholds_enum = 1;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_MEM_MAX:
    nvmlTemperatureThresholds_enum = 2;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_GPU_MAX:
    nvmlTemperatureThresholds_enum = 3;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_COUNT:
    nvmlTemperatureThresholds_enum = 4;
pub type nvmlTemperatureThresholds_enum = raw::c_uint;
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_GPU: nvmlTemperatureSensors_enum = 0;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_COUNT: nvmlTemperatureSensors_enum = 1;
pub type nvmlTemperatureSensors_enum = raw::c_uint;
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum = 0;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_THREAD: nvmlComputeMode_enum = 1;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_PROHIBITED: nvmlComputeMode_enum = 2;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_PROCESS: nvmlComputeMode_enum = 3;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum = 4;
pub type nvmlComputeMode_enum = raw::c_uint;
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_CORRECTED: nvmlMemoryErrorType_enum = 0;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_UNCORRECTED: nvmlMemoryErrorType_enum = 1;
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_COUNT: nvmlMemoryErrorType_enum = 2;
pub type nvmlMemoryErrorType_enum = raw::c_uint;
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
pub const nvmlEccCounterType_enum_NVML_VOLATILE_ECC: nvmlEccCounterType_enum = 0;
pub const nvmlEccCounterType_enum_NVML_AGGREGATE_ECC: nvmlEccCounterType_enum = 1;
pub const nvmlEccCounterType_enum_NVML_ECC_COUNTER_TYPE_COUNT: nvmlEccCounterType_enum = 2;
pub type nvmlEccCounterType_enum = raw::c_uint;
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
pub const nvmlClockType_enum_NVML_CLOCK_GRAPHICS: nvmlClockType_enum = 0;
pub const nvmlClockType_enum_NVML_CLOCK_SM: nvmlClockType_enum = 1;
pub const nvmlClockType_enum_NVML_CLOCK_MEM: nvmlClockType_enum = 2;
pub const nvmlClockType_enum_NVML_CLOCK_VIDEO: nvmlClockType_enum = 3;
pub const nvmlClockType_enum_NVML_CLOCK_COUNT: nvmlClockType_enum = 4;
pub type nvmlClockType_enum = raw::c_uint;
pub use self::nvmlClockType_enum as nvmlClockType_t;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = 0;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum = 1;
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum = 2;
pub const nvmlClockId_enum_NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum = 3;
pub const nvmlClockId_enum_NVML_CLOCK_ID_COUNT: nvmlClockId_enum = 4;
pub type nvmlClockId_enum = raw::c_uint;
pub use self::nvmlClockId_enum as nvmlClockId_t;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDDM: nvmlDriverModel_enum = 0;
pub const nvmlDriverModel_enum_NVML_DRIVER_WDM: nvmlDriverModel_enum = 1;
pub type nvmlDriverModel_enum = raw::c_uint;
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
pub const nvmlPStates_enum_NVML_PSTATE_0: nvmlPStates_enum = 0;
pub const nvmlPStates_enum_NVML_PSTATE_1: nvmlPStates_enum = 1;
pub const nvmlPStates_enum_NVML_PSTATE_2: nvmlPStates_enum = 2;
pub const nvmlPStates_enum_NVML_PSTATE_3: nvmlPStates_enum = 3;
pub const nvmlPStates_enum_NVML_PSTATE_4: nvmlPStates_enum = 4;
pub const nvmlPStates_enum_NVML_PSTATE_5: nvmlPStates_enum = 5;
pub const nvmlPStates_enum_NVML_PSTATE_6: nvmlPStates_enum = 6;
pub const nvmlPStates_enum_NVML_PSTATE_7: nvmlPStates_enum = 7;
pub const nvmlPStates_enum_NVML_PSTATE_8: nvmlPStates_enum = 8;
pub const nvmlPStates_enum_NVML_PSTATE_9: nvmlPStates_enum = 9;
pub const nvmlPStates_enum_NVML_PSTATE_10: nvmlPStates_enum = 10;
pub const nvmlPStates_enum_NVML_PSTATE_11: nvmlPStates_enum = 11;
pub const nvmlPStates_enum_NVML_PSTATE_12: nvmlPStates_enum = 12;
pub const nvmlPStates_enum_NVML_PSTATE_13: nvmlPStates_enum = 13;
pub const nvmlPStates_enum_NVML_PSTATE_14: nvmlPStates_enum = 14;
pub const nvmlPStates_enum_NVML_PSTATE_15: nvmlPStates_enum = 15;
pub const nvmlPStates_enum_NVML_PSTATE_UNKNOWN: nvmlPStates_enum = 32;
pub type nvmlPStates_enum = raw::c_uint;
pub use self::nvmlPStates_enum as nvmlPstates_t;
pub const nvmlGom_enum_NVML_GOM_ALL_ON: nvmlGom_enum = 0;
pub const nvmlGom_enum_NVML_GOM_COMPUTE: nvmlGom_enum = 1;
pub const nvmlGom_enum_NVML_GOM_LOW_DP: nvmlGom_enum = 2;
pub type nvmlGom_enum = raw::c_uint;
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
pub const nvmlInforomObject_enum_NVML_INFOROM_OEM: nvmlInforomObject_enum = 0;
pub const nvmlInforomObject_enum_NVML_INFOROM_ECC: nvmlInforomObject_enum = 1;
pub const nvmlInforomObject_enum_NVML_INFOROM_POWER: nvmlInforomObject_enum = 2;
pub const nvmlInforomObject_enum_NVML_INFOROM_COUNT: nvmlInforomObject_enum = 3;
pub type nvmlInforomObject_enum = raw::c_uint;
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
pub const nvmlReturn_enum_NVML_SUCCESS: nvmlReturn_enum = 0;
pub const nvmlReturn_enum_NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = 1;
pub const nvmlReturn_enum_NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = 2;
pub const nvmlReturn_enum_NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = 3;
pub const nvmlReturn_enum_NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = 4;
pub const nvmlReturn_enum_NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = 5;
pub const nvmlReturn_enum_NVML_ERROR_NOT_FOUND: nvmlReturn_enum = 6;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = 7;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = 8;
pub const nvmlReturn_enum_NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = 9;
pub const nvmlReturn_enum_NVML_ERROR_TIMEOUT: nvmlReturn_enum = 10;
pub const nvmlReturn_enum_NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = 11;
pub const nvmlReturn_enum_NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = 12;
pub const nvmlReturn_enum_NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = 13;
pub const nvmlReturn_enum_NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = 14;
pub const nvmlReturn_enum_NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = 15;
pub const nvmlReturn_enum_NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = 16;
pub const nvmlReturn_enum_NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = 17;
pub const nvmlReturn_enum_NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum = 18;
pub const nvmlReturn_enum_NVML_ERROR_IN_USE: nvmlReturn_enum = 19;
pub const nvmlReturn_enum_NVML_ERROR_MEMORY: nvmlReturn_enum = 20;
pub const nvmlReturn_enum_NVML_ERROR_NO_DATA: nvmlReturn_enum = 21;
pub const nvmlReturn_enum_NVML_ERROR_VGPU_ECC_NOT_SUPPORTED: nvmlReturn_enum = 22;
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_RESOURCES: nvmlReturn_enum = 23;
pub const nvmlReturn_enum_NVML_ERROR_UNKNOWN: nvmlReturn_enum = 999;
pub type nvmlReturn_enum = raw::c_uint;
pub use self::nvmlReturn_enum as nvmlReturn_t;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L1_CACHE: nvmlMemoryLocation_enum = 0;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L2_CACHE: nvmlMemoryLocation_enum = 1;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DRAM: nvmlMemoryLocation_enum = 2;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DEVICE_MEMORY: nvmlMemoryLocation_enum = 2;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_REGISTER_FILE: nvmlMemoryLocation_enum = 3;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_MEMORY: nvmlMemoryLocation_enum = 4;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_SHM: nvmlMemoryLocation_enum = 5;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_CBU: nvmlMemoryLocation_enum = 6;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_SRAM: nvmlMemoryLocation_enum = 7;
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_COUNT: nvmlMemoryLocation_enum = 8;
pub type nvmlMemoryLocation_enum = raw::c_uint;
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
    nvmlPageRetirementCause_enum = 0;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR:
    nvmlPageRetirementCause_enum = 1;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_COUNT:
    nvmlPageRetirementCause_enum = 2;
pub type nvmlPageRetirementCause_enum = raw::c_uint;
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS:
    nvmlRestrictedAPI_enum = 0;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS:
    nvmlRestrictedAPI_enum = 1;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_COUNT: nvmlRestrictedAPI_enum = 2;
pub type nvmlRestrictedAPI_enum = raw::c_uint;
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_NONE: nvmlGpuVirtualizationMode =
    0;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH:
    nvmlGpuVirtualizationMode = 1;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_VGPU: nvmlGpuVirtualizationMode =
    2;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU:
    nvmlGpuVirtualizationMode = 3;
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA:
    nvmlGpuVirtualizationMode = 4;
pub type nvmlGpuVirtualizationMode = raw::c_uint;
pub use self::nvmlGpuVirtualizationMode as nvmlGpuVirtualizationMode_t;
pub const nvmlHostVgpuMode_enum_NVML_HOST_VGPU_MODE_NON_SRIOV: nvmlHostVgpuMode_enum = 0;
pub const nvmlHostVgpuMode_enum_NVML_HOST_VGPU_MODE_SRIOV: nvmlHostVgpuMode_enum = 1;
pub type nvmlHostVgpuMode_enum = raw::c_uint;
pub use self::nvmlHostVgpuMode_enum as nvmlHostVgpuMode_t;
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_DOMAIN_ID: nvmlVgpuVmIdType = 0;
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_UUID: nvmlVgpuVmIdType = 1;
pub type nvmlVgpuVmIdType = raw::c_uint;
pub use self::nvmlVgpuVmIdType as nvmlVgpuVmIdType_t;
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED:
    nvmlVgpuGuestInfoState_enum = 0;
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED:
    nvmlVgpuGuestInfoState_enum = 1;
pub type nvmlVgpuGuestInfoState_enum = raw::c_uint;
pub use self::nvmlVgpuGuestInfoState_enum as nvmlVgpuGuestInfoState_t;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VGPU:
    nvmlGridLicenseFeatureCode_t = 1;
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION:
    nvmlGridLicenseFeatureCode_t = 2;
pub type nvmlGridLicenseFeatureCode_t = raw::c_uint;
pub type nvmlVgpuTypeId_t = raw::c_uint;
pub type nvmlVgpuInstance_t = raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuInstanceUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: nvmlValue_t,
    pub memUtil: nvmlValue_t,
    pub encUtil: nvmlValue_t,
    pub decUtil: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlVgpuInstanceUtilizationSample_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuInstanceUtilizationSample_st>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuInstanceUtilizationSample_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).vgpuInstance
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(vgpuInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).timeStamp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).smUtil as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(smUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).memUtil as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(memUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).encUtil as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(encUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).decUtil as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(decUtil)
        )
    );
}
pub type nvmlVgpuInstanceUtilizationSample_t = nvmlVgpuInstanceUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuProcessUtilizationSample_st {
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub pid: raw::c_uint,
    pub processName: [raw::c_char; 64usize],
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: raw::c_uint,
    pub memUtil: raw::c_uint,
    pub encUtil: raw::c_uint,
    pub decUtil: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlVgpuProcessUtilizationSample_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuProcessUtilizationSample_st>(),
        96usize,
        concat!("Size of: ", stringify!(nvmlVgpuProcessUtilizationSample_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuProcessUtilizationSample_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nvmlVgpuProcessUtilizationSample_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).vgpuInstance as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(vgpuInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).pid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).processName as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(processName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).timeStamp as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).smUtil as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(smUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).memUtil as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(memUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).encUtil as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(encUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).decUtil as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(decUtil)
        )
    );
}
pub type nvmlVgpuProcessUtilizationSample_t = nvmlVgpuProcessUtilizationSample_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessUtilizationSample_st {
    pub pid: raw::c_uint,
    pub timeStamp: raw::c_ulonglong,
    pub smUtil: raw::c_uint,
    pub memUtil: raw::c_uint,
    pub encUtil: raw::c_uint,
    pub decUtil: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlProcessUtilizationSample_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlProcessUtilizationSample_st>(),
        32usize,
        concat!("Size of: ", stringify!(nvmlProcessUtilizationSample_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlProcessUtilizationSample_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlProcessUtilizationSample_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).pid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).timeStamp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).smUtil as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(smUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).memUtil as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(memUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).encUtil as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(encUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).decUtil as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(decUtil)
        )
    );
}
pub type nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeature_st {
    pub featureCode: nvmlGridLicenseFeatureCode_t,
    pub featureState: raw::c_uint,
    pub licenseInfo: [raw::c_char; 128usize],
    pub productName: [raw::c_char; 128usize],
    pub featureEnabled: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlGridLicensableFeature_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlGridLicensableFeature_st>(),
        268usize,
        concat!("Size of: ", stringify!(nvmlGridLicensableFeature_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlGridLicensableFeature_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlGridLicensableFeature_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).featureCode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(featureCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).featureState as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(featureState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).licenseInfo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(licenseInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).productName as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(productName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).featureEnabled as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(featureEnabled)
        )
    );
}
pub type nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeatures_st {
    pub isGridLicenseSupported: raw::c_int,
    pub licensableFeaturesCount: raw::c_uint,
    pub gridLicensableFeatures: [nvmlGridLicensableFeature_t; 3usize],
}
#[test]
fn bindgen_test_layout_nvmlGridLicensableFeatures_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlGridLicensableFeatures_st>(),
        812usize,
        concat!("Size of: ", stringify!(nvmlGridLicensableFeatures_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlGridLicensableFeatures_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlGridLicensableFeatures_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeatures_st>())).isGridLicenseSupported
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeatures_st),
            "::",
            stringify!(isGridLicenseSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeatures_st>())).licensableFeaturesCount
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeatures_st),
            "::",
            stringify!(licensableFeaturesCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeatures_st>())).gridLicensableFeatures
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeatures_st),
            "::",
            stringify!(gridLicensableFeatures)
        )
    );
}
pub type nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st;
pub type nvmlDeviceArchitecture_t = raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFieldValue_st {
    pub fieldId: raw::c_uint,
    pub scopeId: raw::c_uint,
    pub timestamp: raw::c_longlong,
    pub latencyUsec: raw::c_longlong,
    pub valueType: nvmlValueType_t,
    pub nvmlReturn: nvmlReturn_t,
    pub value: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlFieldValue_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlFieldValue_st>(),
        40usize,
        concat!("Size of: ", stringify!(nvmlFieldValue_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlFieldValue_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlFieldValue_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).fieldId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(fieldId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).scopeId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(scopeId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).latencyUsec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(latencyUsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).valueType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(valueType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).nvmlReturn as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(nvmlReturn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(value)
        )
    );
}
pub type nvmlFieldValue_t = nvmlFieldValue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: raw::c_uint,
    pub firmwareVersion: [raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_nvmlHwbcEntry_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlHwbcEntry_st>(),
        36usize,
        concat!("Size of: ", stringify!(nvmlHwbcEntry_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlHwbcEntry_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlHwbcEntry_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlHwbcEntry_st>())).hwbcId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlHwbcEntry_st),
            "::",
            stringify!(hwbcId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlHwbcEntry_st>())).firmwareVersion as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlHwbcEntry_st),
            "::",
            stringify!(firmwareVersion)
        )
    );
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
pub const nvmlFanState_enum_NVML_FAN_NORMAL: nvmlFanState_enum = 0;
pub const nvmlFanState_enum_NVML_FAN_FAILED: nvmlFanState_enum = 1;
pub type nvmlFanState_enum = raw::c_uint;
pub use self::nvmlFanState_enum as nvmlFanState_t;
pub const nvmlLedColor_enum_NVML_LED_COLOR_GREEN: nvmlLedColor_enum = 0;
pub const nvmlLedColor_enum_NVML_LED_COLOR_AMBER: nvmlLedColor_enum = 1;
pub type nvmlLedColor_enum = raw::c_uint;
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlLedState_st {
    pub cause: [raw::c_char; 256usize],
    pub color: nvmlLedColor_t,
}
#[test]
fn bindgen_test_layout_nvmlLedState_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlLedState_st>(),
        260usize,
        concat!("Size of: ", stringify!(nvmlLedState_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlLedState_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlLedState_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlLedState_st>())).cause as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlLedState_st),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlLedState_st>())).color as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlLedState_st),
            "::",
            stringify!(color)
        )
    );
}
pub type nvmlLedState_t = nvmlLedState_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitInfo_st {
    pub name: [raw::c_char; 96usize],
    pub id: [raw::c_char; 96usize],
    pub serial: [raw::c_char; 96usize],
    pub firmwareVersion: [raw::c_char; 96usize],
}
#[test]
fn bindgen_test_layout_nvmlUnitInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlUnitInfo_st>(),
        384usize,
        concat!("Size of: ", stringify!(nvmlUnitInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlUnitInfo_st>(),
        1usize,
        concat!("Alignment of ", stringify!(nvmlUnitInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitInfo_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitInfo_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitInfo_st>())).id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitInfo_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitInfo_st>())).serial as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitInfo_st),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitInfo_st>())).firmwareVersion as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitInfo_st),
            "::",
            stringify!(firmwareVersion)
        )
    );
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlPSUInfo_st {
    pub state: [raw::c_char; 256usize],
    pub current: raw::c_uint,
    pub voltage: raw::c_uint,
    pub power: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlPSUInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlPSUInfo_st>(),
        268usize,
        concat!("Size of: ", stringify!(nvmlPSUInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlPSUInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlPSUInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPSUInfo_st>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPSUInfo_st),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPSUInfo_st>())).current as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPSUInfo_st),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPSUInfo_st>())).voltage as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPSUInfo_st),
            "::",
            stringify!(voltage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPSUInfo_st>())).power as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPSUInfo_st),
            "::",
            stringify!(power)
        )
    );
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitFanInfo_st {
    pub speed: raw::c_uint,
    pub state: nvmlFanState_t,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlUnitFanInfo_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlUnitFanInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlUnitFanInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlUnitFanInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitFanInfo_st>())).speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitFanInfo_st),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitFanInfo_st>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitFanInfo_st),
            "::",
            stringify!(state)
        )
    );
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitFanSpeeds_st {
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    pub count: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanSpeeds_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlUnitFanSpeeds_st>(),
        196usize,
        concat!("Size of: ", stringify!(nvmlUnitFanSpeeds_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlUnitFanSpeeds_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlUnitFanSpeeds_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitFanSpeeds_st>())).fans as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitFanSpeeds_st),
            "::",
            stringify!(fans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitFanSpeeds_st>())).count as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitFanSpeeds_st),
            "::",
            stringify!(count)
        )
    );
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventData_st {
    pub device: nvmlDevice_t,
    pub eventType: raw::c_ulonglong,
    pub eventData: raw::c_ulonglong,
    pub gpuInstanceId: raw::c_uint,
    pub computeInstanceId: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlEventData_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlEventData_st>(),
        32usize,
        concat!("Size of: ", stringify!(nvmlEventData_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlEventData_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlEventData_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEventData_st>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEventData_st),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEventData_st>())).eventType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEventData_st),
            "::",
            stringify!(eventType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEventData_st>())).eventData as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEventData_st),
            "::",
            stringify!(eventData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEventData_st>())).gpuInstanceId as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEventData_st),
            "::",
            stringify!(gpuInstanceId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEventData_st>())).computeInstanceId as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEventData_st),
            "::",
            stringify!(computeInstanceId)
        )
    );
}
pub type nvmlEventData_t = nvmlEventData_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlAccountingStats_st {
    pub gpuUtilization: raw::c_uint,
    pub memoryUtilization: raw::c_uint,
    pub maxMemoryUsage: raw::c_ulonglong,
    pub time: raw::c_ulonglong,
    pub startTime: raw::c_ulonglong,
    pub isRunning: raw::c_uint,
    pub reserved: [raw::c_uint; 5usize],
}
#[test]
fn bindgen_test_layout_nvmlAccountingStats_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlAccountingStats_st>(),
        56usize,
        concat!("Size of: ", stringify!(nvmlAccountingStats_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlAccountingStats_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlAccountingStats_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).gpuUtilization as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(gpuUtilization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).memoryUtilization as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(memoryUtilization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).maxMemoryUsage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(maxMemoryUsage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlAccountingStats_st>())).time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).startTime as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(startTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).isRunning as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(isRunning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlAccountingStats_st>())).reserved as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_H264: nvmlEncoderQueryType_enum = 0;
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_HEVC: nvmlEncoderQueryType_enum = 1;
pub type nvmlEncoderQueryType_enum = raw::c_uint;
pub use self::nvmlEncoderQueryType_enum as nvmlEncoderType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEncoderSessionInfo_st {
    pub sessionId: raw::c_uint,
    pub pid: raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub codecType: nvmlEncoderType_t,
    pub hResolution: raw::c_uint,
    pub vResolution: raw::c_uint,
    pub averageFps: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlEncoderSessionInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlEncoderSessionInfo_st>(),
        32usize,
        concat!("Size of: ", stringify!(nvmlEncoderSessionInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlEncoderSessionInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlEncoderSessionInfo_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).sessionId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(sessionId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).vgpuInstance as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(vgpuInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).codecType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(codecType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).hResolution as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(hResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).vResolution as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(vResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).averageFps as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(averageFps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).averageLatency as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(averageLatency)
        )
    );
}
pub type nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_UNKNOWN: nvmlFBCSessionType_enum = 0;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_TOSYS: nvmlFBCSessionType_enum = 1;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_CUDA: nvmlFBCSessionType_enum = 2;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_VID: nvmlFBCSessionType_enum = 3;
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_HWENC: nvmlFBCSessionType_enum = 4;
pub type nvmlFBCSessionType_enum = raw::c_uint;
pub use self::nvmlFBCSessionType_enum as nvmlFBCSessionType_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlFBCStats_st {
    pub sessionsCount: raw::c_uint,
    pub averageFPS: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlFBCStats_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlFBCStats_st>(),
        12usize,
        concat!("Size of: ", stringify!(nvmlFBCStats_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlFBCStats_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlFBCStats_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCStats_st>())).sessionsCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCStats_st),
            "::",
            stringify!(sessionsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCStats_st>())).averageFPS as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCStats_st),
            "::",
            stringify!(averageFPS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCStats_st>())).averageLatency as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCStats_st),
            "::",
            stringify!(averageLatency)
        )
    );
}
pub type nvmlFBCStats_t = nvmlFBCStats_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlFBCSessionInfo_st {
    pub sessionId: raw::c_uint,
    pub pid: raw::c_uint,
    pub vgpuInstance: nvmlVgpuInstance_t,
    pub displayOrdinal: raw::c_uint,
    pub sessionType: nvmlFBCSessionType_t,
    pub sessionFlags: raw::c_uint,
    pub hMaxResolution: raw::c_uint,
    pub vMaxResolution: raw::c_uint,
    pub hResolution: raw::c_uint,
    pub vResolution: raw::c_uint,
    pub averageFPS: raw::c_uint,
    pub averageLatency: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlFBCSessionInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlFBCSessionInfo_st>(),
        48usize,
        concat!("Size of: ", stringify!(nvmlFBCSessionInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlFBCSessionInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlFBCSessionInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).sessionId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(sessionId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).vgpuInstance as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(vgpuInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).displayOrdinal as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(displayOrdinal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).sessionType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(sessionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).sessionFlags as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(sessionFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).hMaxResolution as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(hMaxResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).vMaxResolution as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(vMaxResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).hResolution as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(hResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).vResolution as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(vResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).averageFPS as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(averageFPS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).averageLatency as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(averageLatency)
        )
    );
}
pub type nvmlFBCSessionInfo_t = nvmlFBCSessionInfo_st;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_KEEP: nvmlDetachGpuState_enum = 0;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_REMOVE: nvmlDetachGpuState_enum = 1;
pub type nvmlDetachGpuState_enum = raw::c_uint;
pub use self::nvmlDetachGpuState_enum as nvmlDetachGpuState_t;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_KEEP: nvmlPcieLinkState_enum = 0;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_SHUT_DOWN: nvmlPcieLinkState_enum = 1;
pub type nvmlPcieLinkState_enum = raw::c_uint;
pub use self::nvmlPcieLinkState_enum as nvmlPcieLinkState_t;
pub type nvmlAffinityScope_t = raw::c_uint;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_RANGE_START: nvmlClockLimitId_enum = 4294967040;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_TDP: nvmlClockLimitId_enum = 4294967041;
pub const nvmlClockLimitId_enum_NVML_CLOCK_LIMIT_ID_UNLIMITED: nvmlClockLimitId_enum = 4294967042;
pub type nvmlClockLimitId_enum = raw::c_uint;
pub use self::nvmlClockLimitId_enum as nvmlClockLimitId_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuVersion_st {
    pub minVersion: raw::c_uint,
    pub maxVersion: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlVgpuVersion_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuVersion_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlVgpuVersion_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuVersion_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlVgpuVersion_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuVersion_st>())).minVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuVersion_st),
            "::",
            stringify!(minVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuVersion_st>())).maxVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuVersion_st),
            "::",
            stringify!(maxVersion)
        )
    );
}
pub type nvmlVgpuVersion_t = nvmlVgpuVersion_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuMetadata_st {
    pub version: raw::c_uint,
    pub revision: raw::c_uint,
    pub guestInfoState: nvmlVgpuGuestInfoState_t,
    pub guestDriverVersion: [raw::c_char; 80usize],
    pub hostDriverVersion: [raw::c_char; 80usize],
    pub reserved: [raw::c_uint; 6usize],
    pub vgpuVirtualizationCaps: raw::c_uint,
    pub guestVgpuVersion: raw::c_uint,
    pub opaqueDataSize: raw::c_uint,
    pub opaqueData: [raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_nvmlVgpuMetadata_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuMetadata_st>(),
        212usize,
        concat!("Size of: ", stringify!(nvmlVgpuMetadata_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuMetadata_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlVgpuMetadata_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).revision as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).guestInfoState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(guestInfoState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).guestDriverVersion as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(guestDriverVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).hostDriverVersion as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(hostDriverVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).reserved as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).vgpuVirtualizationCaps as *const _
                as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(vgpuVirtualizationCaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).guestVgpuVersion as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(guestVgpuVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).opaqueDataSize as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(opaqueDataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).opaqueData as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(opaqueData)
        )
    );
}
pub type nvmlVgpuMetadata_t = nvmlVgpuMetadata_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuPgpuMetadata_st {
    pub version: raw::c_uint,
    pub revision: raw::c_uint,
    pub hostDriverVersion: [raw::c_char; 80usize],
    pub pgpuVirtualizationCaps: raw::c_uint,
    pub reserved: [raw::c_uint; 5usize],
    pub hostSupportedVgpuRange: nvmlVgpuVersion_t,
    pub opaqueDataSize: raw::c_uint,
    pub opaqueData: [raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_nvmlVgpuPgpuMetadata_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuPgpuMetadata_st>(),
        128usize,
        concat!("Size of: ", stringify!(nvmlVgpuPgpuMetadata_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuPgpuMetadata_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlVgpuPgpuMetadata_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).revision as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).hostDriverVersion as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(hostDriverVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).pgpuVirtualizationCaps as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(pgpuVirtualizationCaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).reserved as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).hostSupportedVgpuRange as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(hostSupportedVgpuRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).opaqueDataSize as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(opaqueDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).opaqueData as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(opaqueData)
        )
    );
}
pub type nvmlVgpuPgpuMetadata_t = nvmlVgpuPgpuMetadata_st;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_NONE:
    nvmlVgpuVmCompatibility_enum = 0;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_COLD:
    nvmlVgpuVmCompatibility_enum = 1;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_HIBERNATE:
    nvmlVgpuVmCompatibility_enum = 2;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_SLEEP:
    nvmlVgpuVmCompatibility_enum = 4;
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_LIVE:
    nvmlVgpuVmCompatibility_enum = 8;
pub type nvmlVgpuVmCompatibility_enum = raw::c_uint;
pub use self::nvmlVgpuVmCompatibility_enum as nvmlVgpuVmCompatibility_t;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_NONE:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 0;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 1;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GPU:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 4;
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_OTHER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2147483648;
pub type nvmlVgpuPgpuCompatibilityLimitCode_enum = raw::c_uint;
pub use self::nvmlVgpuPgpuCompatibilityLimitCode_enum as nvmlVgpuPgpuCompatibilityLimitCode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuPgpuCompatibility_st {
    pub vgpuVmCompatibility: nvmlVgpuVmCompatibility_t,
    pub compatibilityLimitCode: nvmlVgpuPgpuCompatibilityLimitCode_t,
}
#[test]
fn bindgen_test_layout_nvmlVgpuPgpuCompatibility_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuPgpuCompatibility_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlVgpuPgpuCompatibility_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuPgpuCompatibility_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlVgpuPgpuCompatibility_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuCompatibility_st>())).vgpuVmCompatibility as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuCompatibility_st),
            "::",
            stringify!(vgpuVmCompatibility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuCompatibility_st>())).compatibilityLimitCode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuCompatibility_st),
            "::",
            stringify!(compatibilityLimitCode)
        )
    );
}
pub type nvmlVgpuPgpuCompatibility_t = nvmlVgpuPgpuCompatibility_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBlacklistDeviceInfo_st {
    pub pciInfo: nvmlPciInfo_t,
    pub uuid: [raw::c_char; 80usize],
}
#[test]
fn bindgen_test_layout_nvmlBlacklistDeviceInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlBlacklistDeviceInfo_st>(),
        148usize,
        concat!("Size of: ", stringify!(nvmlBlacklistDeviceInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlBlacklistDeviceInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlBlacklistDeviceInfo_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlBlacklistDeviceInfo_st>())).pciInfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBlacklistDeviceInfo_st),
            "::",
            stringify!(pciInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBlacklistDeviceInfo_st>())).uuid as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBlacklistDeviceInfo_st),
            "::",
            stringify!(uuid)
        )
    );
}
pub type nvmlBlacklistDeviceInfo_t = nvmlBlacklistDeviceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstancePlacement_st {
    pub start: raw::c_uint,
    pub size: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlGpuInstancePlacement_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlGpuInstancePlacement_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlGpuInstancePlacement_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlGpuInstancePlacement_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlGpuInstancePlacement_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstancePlacement_st>())).start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstancePlacement_st),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstancePlacement_st>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstancePlacement_st),
            "::",
            stringify!(size)
        )
    );
}
pub type nvmlGpuInstancePlacement_t = nvmlGpuInstancePlacement_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstanceProfileInfo_st {
    pub id: raw::c_uint,
    pub isP2pSupported: raw::c_uint,
    pub sliceCount: raw::c_uint,
    pub instanceCount: raw::c_uint,
    pub multiprocessorCount: raw::c_uint,
    pub copyEngineCount: raw::c_uint,
    pub decoderCount: raw::c_uint,
    pub encoderCount: raw::c_uint,
    pub jpegCount: raw::c_uint,
    pub ofaCount: raw::c_uint,
    pub memorySizeMB: raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlGpuInstanceProfileInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlGpuInstanceProfileInfo_st>(),
        48usize,
        concat!("Size of: ", stringify!(nvmlGpuInstanceProfileInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlGpuInstanceProfileInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlGpuInstanceProfileInfo_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).isP2pSupported as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(isP2pSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).sliceCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(sliceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).instanceCount as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(instanceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).multiprocessorCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(multiprocessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).copyEngineCount as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(copyEngineCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).decoderCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(decoderCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).encoderCount as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(encoderCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).jpegCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(jpegCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).ofaCount as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(ofaCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceProfileInfo_st>())).memorySizeMB as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceProfileInfo_st),
            "::",
            stringify!(memorySizeMB)
        )
    );
}
pub type nvmlGpuInstanceProfileInfo_t = nvmlGpuInstanceProfileInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub id: raw::c_uint,
    pub profileId: raw::c_uint,
    pub placement: nvmlGpuInstancePlacement_t,
}
#[test]
fn bindgen_test_layout_nvmlGpuInstanceInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlGpuInstanceInfo_st>(),
        24usize,
        concat!("Size of: ", stringify!(nvmlGpuInstanceInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlGpuInstanceInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlGpuInstanceInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlGpuInstanceInfo_st>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceInfo_st),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlGpuInstanceInfo_st>())).id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceInfo_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceInfo_st>())).profileId as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceInfo_st),
            "::",
            stringify!(profileId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGpuInstanceInfo_st>())).placement as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGpuInstanceInfo_st),
            "::",
            stringify!(placement)
        )
    );
}
pub type nvmlGpuInstanceInfo_t = nvmlGpuInstanceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlGpuInstance_st {
    _unused: [u8; 0],
}
pub type nvmlGpuInstance_t = *mut nvmlGpuInstance_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstancePlacement_st {
    pub start: raw::c_uint,
    pub size: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlComputeInstancePlacement_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlComputeInstancePlacement_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlComputeInstancePlacement_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlComputeInstancePlacement_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlComputeInstancePlacement_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstancePlacement_st>())).start as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstancePlacement_st),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstancePlacement_st>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstancePlacement_st),
            "::",
            stringify!(size)
        )
    );
}
pub type nvmlComputeInstancePlacement_t = nvmlComputeInstancePlacement_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstanceProfileInfo_st {
    pub id: raw::c_uint,
    pub sliceCount: raw::c_uint,
    pub instanceCount: raw::c_uint,
    pub multiprocessorCount: raw::c_uint,
    pub sharedCopyEngineCount: raw::c_uint,
    pub sharedDecoderCount: raw::c_uint,
    pub sharedEncoderCount: raw::c_uint,
    pub sharedJpegCount: raw::c_uint,
    pub sharedOfaCount: raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlComputeInstanceProfileInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlComputeInstanceProfileInfo_st>(),
        36usize,
        concat!("Size of: ", stringify!(nvmlComputeInstanceProfileInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlComputeInstanceProfileInfo_st>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(nvmlComputeInstanceProfileInfo_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).sliceCount as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(sliceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).instanceCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(instanceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).multiprocessorCount
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(multiprocessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).sharedCopyEngineCount
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(sharedCopyEngineCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).sharedDecoderCount
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(sharedDecoderCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).sharedEncoderCount
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(sharedEncoderCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).sharedJpegCount
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(sharedJpegCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceProfileInfo_st>())).sharedOfaCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceProfileInfo_st),
            "::",
            stringify!(sharedOfaCount)
        )
    );
}
pub type nvmlComputeInstanceProfileInfo_t = nvmlComputeInstanceProfileInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstanceInfo_st {
    pub device: nvmlDevice_t,
    pub gpuInstance: nvmlGpuInstance_t,
    pub id: raw::c_uint,
    pub profileId: raw::c_uint,
    pub placement: nvmlComputeInstancePlacement_t,
}
#[test]
fn bindgen_test_layout_nvmlComputeInstanceInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlComputeInstanceInfo_st>(),
        32usize,
        concat!("Size of: ", stringify!(nvmlComputeInstanceInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlComputeInstanceInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlComputeInstanceInfo_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceInfo_st>())).device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceInfo_st),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceInfo_st>())).gpuInstance as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceInfo_st),
            "::",
            stringify!(gpuInstance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlComputeInstanceInfo_st>())).id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceInfo_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceInfo_st>())).profileId as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceInfo_st),
            "::",
            stringify!(profileId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlComputeInstanceInfo_st>())).placement as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlComputeInstanceInfo_st),
            "::",
            stringify!(placement)
        )
    );
}
pub type nvmlComputeInstanceInfo_t = nvmlComputeInstanceInfo_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlComputeInstance_st {
    _unused: [u8; 0],
}
pub type nvmlComputeInstance_t = *mut nvmlComputeInstance_st;
extern crate libloading;
pub struct nvml {
    __library: ::libloading::Library,
    pub nvmlInit_v2: Result<unsafe extern "C" fn() -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlInitWithFlags:
        Result<unsafe extern "C" fn(flags: raw::c_uint) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlShutdown: Result<unsafe extern "C" fn() -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlErrorString: Result<
        unsafe extern "C" fn(result: nvmlReturn_t) -> *const raw::c_char,
        ::libloading::Error,
    >,
    pub nvmlSystemGetDriverVersion: Result<
        unsafe extern "C" fn(version: *mut raw::c_char, length: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetNVMLVersion: Result<
        unsafe extern "C" fn(version: *mut raw::c_char, length: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetCudaDriverVersion: Result<
        unsafe extern "C" fn(cudaDriverVersion: *mut raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetCudaDriverVersion_v2: Result<
        unsafe extern "C" fn(cudaDriverVersion: *mut raw::c_int) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetProcessName: Result<
        unsafe extern "C" fn(
            pid: raw::c_uint,
            name: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetCount: Result<
        unsafe extern "C" fn(unitCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetHandleByIndex: Result<
        unsafe extern "C" fn(index: raw::c_uint, unit: *mut nvmlUnit_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetUnitInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetLedState: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, state: *mut nvmlLedState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetPsuInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetTemperature: Result<
        unsafe extern "C" fn(
            unit: nvmlUnit_t,
            type_: raw::c_uint,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetFanSpeedInfo: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, fanSpeeds: *mut nvmlUnitFanSpeeds_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitGetDevices: Result<
        unsafe extern "C" fn(
            unit: nvmlUnit_t,
            deviceCount: *mut raw::c_uint,
            devices: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetHicVersion: Result<
        unsafe extern "C" fn(
            hwbcCount: *mut raw::c_uint,
            hwbcEntries: *mut nvmlHwbcEntry_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCount_v2: Result<
        unsafe extern "C" fn(deviceCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAttributes_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            attributes: *mut nvmlDeviceAttributes_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByIndex_v2: Result<
        unsafe extern "C" fn(index: raw::c_uint, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleBySerial: Result<
        unsafe extern "C" fn(serial: *const raw::c_char, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByUUID: Result<
        unsafe extern "C" fn(uuid: *const raw::c_char, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHandleByPciBusId_v2: Result<
        unsafe extern "C" fn(
            pciBusId: *const raw::c_char,
            device: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetName: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            name: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBrand: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, type_: *mut nvmlBrandType_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetIndex: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, index: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSerial: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            serial: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryAffinity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            nodeSetSize: raw::c_uint,
            nodeSet: *mut raw::c_ulong,
            scope: nvmlAffinityScope_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCpuAffinityWithinScope: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cpuSetSize: raw::c_uint,
            cpuSet: *mut raw::c_ulong,
            scope: nvmlAffinityScope_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCpuAffinity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cpuSetSize: raw::c_uint,
            cpuSet: *mut raw::c_ulong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetCpuAffinity:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceClearCpuAffinity:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetTopologyCommonAncestor: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            pathInfo: *mut nvmlGpuTopologyLevel_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTopologyNearestGpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            level: nvmlGpuTopologyLevel_t,
            count: *mut raw::c_uint,
            deviceArray: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSystemGetTopologyGpuSet: Result<
        unsafe extern "C" fn(
            cpuNumber: raw::c_uint,
            count: *mut raw::c_uint,
            deviceArray: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetP2PStatus: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            p2pIndex: nvmlGpuP2PCapsIndex_t,
            p2pStatus: *mut nvmlGpuP2PStatus_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetUUID: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            uuid: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetMdevUUID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            mdevUuid: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMinorNumber: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, minorNumber: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBoardPartNumber: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            partNumber: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            object: nvmlInforomObject_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomImageVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetInforomConfigurationChecksum: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, checksum: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceValidateInforom:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetDisplayMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, display: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDisplayActive: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isActive: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPersistenceMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPciInfo_v3: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pci: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxPcieLinkGeneration: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, maxLinkGen: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxPcieLinkWidth: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, maxLinkWidth: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrPcieLinkGeneration: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, currLinkGen: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrPcieLinkWidth: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, currLinkWidth: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPcieThroughput: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            counter: nvmlPcieUtilCounter_t,
            value: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPcieReplayCounter: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, value: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetClockInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlClockType_t,
            clock: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxClockInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlClockType_t,
            clock: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetApplicationsClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDefaultApplicationsClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetApplicationsClocks:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockId: nvmlClockId_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxCustomerBoostClock: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clockType: nvmlClockType_t,
            clockMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedMemoryClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            count: *mut raw::c_uint,
            clocksMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedGraphicsClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            memoryClockMHz: raw::c_uint,
            count: *mut raw::c_uint,
            clocksMHz: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isEnabled: *mut nvmlEnableState_t,
            defaultIsEnabled: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, enabled: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetDefaultAutoBoostedClocksEnabled: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            enabled: nvmlEnableState_t,
            flags: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFanSpeed: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, speed: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFanSpeed_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            fan: raw::c_uint,
            speed: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTemperature: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sensorType: nvmlTemperatureSensors_t,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTemperatureThreshold: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            thresholdType: nvmlTemperatureThresholds_t,
            temp: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPerformanceState: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pState: *mut nvmlPstates_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCurrentClocksThrottleReasons: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            clocksThrottleReasons: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedClocksThrottleReasons: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            supportedClocksThrottleReasons: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerState: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, pState: *mut nvmlPstates_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementLimitConstraints: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minLimit: *mut raw::c_uint,
            maxLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerManagementDefaultLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, defaultLimit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPowerUsage: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, power: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTotalEnergyConsumption: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, energy: *mut raw::c_ulonglong) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEnforcedPowerLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuOperationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlGpuOperationMode_t,
            pending: *mut nvmlGpuOperationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryInfo: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, memory: *mut nvmlMemory_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlComputeMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCudaComputeCapability: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            major: *mut raw::c_int,
            minor: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEccMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlEnableState_t,
            pending: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBoardId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, boardId: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMultiGpuBoard: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, multiGpuBool: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetTotalEccErrors: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            eccCounts: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDetailedEccErrors: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            eccCounts: *mut nvmlEccErrorCounts_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMemoryErrorCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            errorType: nvmlMemoryErrorType_t,
            counterType: nvmlEccCounterType_t,
            locationType: nvmlMemoryLocation_t,
            count: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetUtilizationRates: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut nvmlUtilization_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut raw::c_uint,
            samplingPeriodUs: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderCapacity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            encoderQueryType: nvmlEncoderType_t,
            encoderCapacity: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderStats: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            averageFps: *mut raw::c_uint,
            averageLatency: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetEncoderSessions: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            sessionInfos: *mut nvmlEncoderSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDecoderUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut raw::c_uint,
            samplingPeriodUs: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFBCStats: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, fbcStats: *mut nvmlFBCStats_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFBCSessions: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlFBCSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDriverModel: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            current: *mut nvmlDriverModel_t,
            pending: *mut nvmlDriverModel_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVbiosVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBridgeChipInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeRunningProcesses_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGraphicsRunningProcesses_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            infoCount: *mut raw::c_uint,
            infos: *mut nvmlProcessInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceOnSameBoard: Result<
        unsafe extern "C" fn(
            device1: nvmlDevice_t,
            device2: nvmlDevice_t,
            onSameBoard: *mut raw::c_int,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAPIRestriction: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            apiType: nvmlRestrictedAPI_t,
            isRestricted: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSamples: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            type_: nvmlSamplingType_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            sampleValType: *mut nvmlValueType_t,
            sampleCount: *mut raw::c_uint,
            samples: *mut nvmlSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetBAR1MemoryInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            bar1Memory: *mut nvmlBAR1Memory_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetViolationStatus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            perfPolicyType: nvmlPerfPolicyType_t,
            violTime: *mut nvmlViolationTime_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: *mut nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingStats: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pid: raw::c_uint,
            stats: *mut nvmlAccountingStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingPids: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            count: *mut raw::c_uint,
            pids: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetAccountingBufferSize: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, bufferSize: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPages: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cause: nvmlPageRetirementCause_t,
            pageCount: *mut raw::c_uint,
            addresses: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPages_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            cause: nvmlPageRetirementCause_t,
            pageCount: *mut raw::c_uint,
            addresses: *mut raw::c_ulonglong,
            timestamps: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRetiredPagesPendingStatus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            isPending: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRemappedRows: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            corrRows: *mut raw::c_uint,
            uncRows: *mut raw::c_uint,
            isPending: *mut raw::c_uint,
            failureOccurred: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetRowRemapperHistogram: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            values: *mut nvmlRowRemapperHistogramValues_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetArchitecture: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            arch: *mut nvmlDeviceArchitecture_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlUnitSetLedState: Result<
        unsafe extern "C" fn(unit: nvmlUnit_t, color: nvmlLedColor_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetPersistenceMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetComputeMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlComputeMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetEccMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, ecc: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceClearEccErrorCounts: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            counterType: nvmlEccCounterType_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetDriverModel: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            driverModel: nvmlDriverModel_t,
            flags: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetGpuLockedClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            minGpuClockMHz: raw::c_uint,
            maxGpuClockMHz: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetGpuLockedClocks:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceSetApplicationsClocks: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            memClockMHz: raw::c_uint,
            graphicsClockMHz: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetPowerManagementLimit: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, limit: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetGpuOperationMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlGpuOperationMode_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAPIRestriction: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            apiType: nvmlRestrictedAPI_t,
            isRestricted: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetAccountingMode: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, mode: nvmlEnableState_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceClearAccountingPids:
        Result<unsafe extern "C" fn(device: nvmlDevice_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceGetNvLinkState: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            isActive: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkVersion: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            version: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkCapability: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            capability: nvmlNvLinkCapability_t,
            capResult: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkRemotePciInfo_v2: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            pci: *mut nvmlPciInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkErrorCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: nvmlNvLinkErrorCounter_t,
            counterValue: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetNvLinkErrorCounters: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, link: raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetNvLinkUtilizationControl: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            control: *mut nvmlNvLinkUtilizationControl_t,
            reset: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkUtilizationControl: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            control: *mut nvmlNvLinkUtilizationControl_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            rxcounter: *mut raw::c_ulonglong,
            txcounter: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceFreezeNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
            freeze: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceResetNvLinkUtilizationCounter: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            link: raw::c_uint,
            counter: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetCreate:
        Result<unsafe extern "C" fn(set: *mut nvmlEventSet_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceRegisterEvents: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            eventTypes: raw::c_ulonglong,
            set: nvmlEventSet_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedEventTypes: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            eventTypes: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetWait_v2: Result<
        unsafe extern "C" fn(
            set: nvmlEventSet_t,
            data: *mut nvmlEventData_t,
            timeoutms: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlEventSetFree:
        Result<unsafe extern "C" fn(set: nvmlEventSet_t) -> nvmlReturn_t, ::libloading::Error>,
    pub nvmlDeviceModifyDrainState: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            newState: nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceQueryDrainState: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            currentState: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceRemoveGpu_v2: Result<
        unsafe extern "C" fn(
            pciInfo: *mut nvmlPciInfo_t,
            gpuState: nvmlDetachGpuState_t,
            linkState: nvmlPcieLinkState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceDiscoverGpus: Result<
        unsafe extern "C" fn(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetFieldValues: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            valuesCount: raw::c_int,
            values: *mut nvmlFieldValue_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVirtualizationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetHostVgpuMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pHostVgpuMode: *mut nvmlHostVgpuMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetVirtualizationMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            virtualMode: nvmlGpuVirtualizationMode_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGridLicensableFeatures_v3: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetProcessUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            utilization: *mut nvmlProcessUtilizationSample_t,
            processSamplesCount: *mut raw::c_uint,
            lastSeenTimeStamp: raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetSupportedVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuTypeIds: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetCreatableVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuTypeIds: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetClass: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeClass: *mut raw::c_char,
            size: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetName: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeName: *mut raw::c_char,
            size: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetGpuInstanceProfileId: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            gpuInstanceProfileId: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetDeviceID: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            deviceID: *mut raw::c_ulonglong,
            subsystemID: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetFramebufferSize: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            fbSize: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetNumDisplayHeads: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            numDisplayHeads: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetResolution: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            displayIndex: raw::c_uint,
            xdim: *mut raw::c_uint,
            ydim: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetLicense: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuTypeLicenseString: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetFrameRateLimit: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            frameRateLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetMaxInstances: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuInstanceCount: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuTypeGetMaxInstancesPerVm: Result<
        unsafe extern "C" fn(
            vgpuTypeId: nvmlVgpuTypeId_t,
            vgpuInstanceCountPerVm: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetActiveVgpus: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            vgpuCount: *mut raw::c_uint,
            vgpuInstances: *mut nvmlVgpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetVmID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vmId: *mut raw::c_char,
            size: raw::c_uint,
            vmIdType: *mut nvmlVgpuVmIdType_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetUUID: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            uuid: *mut raw::c_char,
            size: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetVmDriverVersion: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            version: *mut raw::c_char,
            length: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFbUsage: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            fbUsage: *mut raw::c_ulonglong,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetLicenseStatus: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            licensed: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetType: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vgpuTypeId: *mut nvmlVgpuTypeId_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFrameRateLimit: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            frameRateLimit: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEccMode: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            eccMode: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderCapacity: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            encoderCapacity: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceSetEncoderCapacity: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            encoderCapacity: raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            averageFps: *mut raw::c_uint,
            averageLatency: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetEncoderSessions: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlEncoderSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFBCStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            fbcStats: *mut nvmlFBCStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetFBCSessions: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            sessionCount: *mut raw::c_uint,
            sessionInfo: *mut nvmlFBCSessionInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetMetadata: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            vgpuMetadata: *mut nvmlVgpuMetadata_t,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuMetadata: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetVgpuCompatibility: Result<
        unsafe extern "C" fn(
            vgpuMetadata: *mut nvmlVgpuMetadata_t,
            pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
            compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetPgpuMetadataString: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            pgpuMetadata: *mut raw::c_char,
            bufferSize: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetVgpuVersion: Result<
        unsafe extern "C" fn(
            supported: *mut nvmlVgpuVersion_t,
            current: *mut nvmlVgpuVersion_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlSetVgpuVersion: Result<
        unsafe extern "C" fn(vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            sampleValType: *mut nvmlValueType_t,
            vgpuInstanceSamplesCount: *mut raw::c_uint,
            utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetVgpuProcessUtilization: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            lastSeenTimeStamp: raw::c_ulonglong,
            vgpuProcessSamplesCount: *mut raw::c_uint,
            utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingMode: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            mode: *mut nvmlEnableState_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingPids: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            count: *mut raw::c_uint,
            pids: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceGetAccountingStats: Result<
        unsafe extern "C" fn(
            vgpuInstance: nvmlVgpuInstance_t,
            pid: raw::c_uint,
            stats: *mut nvmlAccountingStats_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlVgpuInstanceClearAccountingPids: Result<
        unsafe extern "C" fn(vgpuInstance: nvmlVgpuInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetBlacklistDeviceCount: Result<
        unsafe extern "C" fn(deviceCount: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGetBlacklistDeviceInfoByIndex: Result<
        unsafe extern "C" fn(
            index: raw::c_uint,
            info: *mut nvmlBlacklistDeviceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceSetMigMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            mode: raw::c_uint,
            activationStatus: *mut nvmlReturn_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMigMode: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            currentMode: *mut raw::c_uint,
            pendingMode: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceProfileInfo: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profile: raw::c_uint,
            info: *mut nvmlGpuInstanceProfileInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstancePossiblePlacements: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            placements: *mut nvmlGpuInstancePlacement_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceRemainingCapacity: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceCreateGpuInstance: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            gpuInstance: *mut nvmlGpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceDestroy: Result<
        unsafe extern "C" fn(gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstances: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            profileId: raw::c_uint,
            gpuInstances: *mut nvmlGpuInstance_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceById: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            id: raw::c_uint,
            gpuInstance: *mut nvmlGpuInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetInfo: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            info: *mut nvmlGpuInstanceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceProfileInfo: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profile: raw::c_uint,
            engProfile: raw::c_uint,
            info: *mut nvmlComputeInstanceProfileInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceRemainingCapacity: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceCreateComputeInstance: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            computeInstance: *mut nvmlComputeInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlComputeInstanceDestroy: Result<
        unsafe extern "C" fn(computeInstance: nvmlComputeInstance_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstances: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            profileId: raw::c_uint,
            computeInstances: *mut nvmlComputeInstance_t,
            count: *mut raw::c_uint,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlGpuInstanceGetComputeInstanceById: Result<
        unsafe extern "C" fn(
            gpuInstance: nvmlGpuInstance_t,
            id: raw::c_uint,
            computeInstance: *mut nvmlComputeInstance_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlComputeInstanceGetInfo_v2: Result<
        unsafe extern "C" fn(
            computeInstance: nvmlComputeInstance_t,
            info: *mut nvmlComputeInstanceInfo_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceIsMigDeviceHandle: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, isMigDevice: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetGpuInstanceId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, id: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetComputeInstanceId: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, id: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMaxMigDeviceCount: Result<
        unsafe extern "C" fn(device: nvmlDevice_t, count: *mut raw::c_uint) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetMigDeviceHandleByIndex: Result<
        unsafe extern "C" fn(
            device: nvmlDevice_t,
            index: raw::c_uint,
            migDevice: *mut nvmlDevice_t,
        ) -> nvmlReturn_t,
        ::libloading::Error,
    >,
    pub nvmlDeviceGetDeviceHandleFromMigDeviceHandle: Result<
        unsafe extern "C" fn(migDevice: nvmlDevice_t, device: *mut nvmlDevice_t) -> nvmlReturn_t,
        ::libloading::Error,
    >,
}
impl nvml {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let __library = ::libloading::Library::new(path)?;
        let nvmlInit_v2 = __library.get("nvmlInit_v2".as_bytes()).map(|sym| *sym);
        let nvmlInitWithFlags = __library
            .get("nvmlInitWithFlags".as_bytes())
            .map(|sym| *sym);
        let nvmlShutdown = __library.get("nvmlShutdown".as_bytes()).map(|sym| *sym);
        let nvmlErrorString = __library.get("nvmlErrorString".as_bytes()).map(|sym| *sym);
        let nvmlSystemGetDriverVersion = __library
            .get("nvmlSystemGetDriverVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlSystemGetNVMLVersion = __library
            .get("nvmlSystemGetNVMLVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlSystemGetCudaDriverVersion = __library
            .get("nvmlSystemGetCudaDriverVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlSystemGetCudaDriverVersion_v2 = __library
            .get("nvmlSystemGetCudaDriverVersion_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlSystemGetProcessName = __library
            .get("nvmlSystemGetProcessName".as_bytes())
            .map(|sym| *sym);
        let nvmlUnitGetCount = __library.get("nvmlUnitGetCount".as_bytes()).map(|sym| *sym);
        let nvmlUnitGetHandleByIndex = __library
            .get("nvmlUnitGetHandleByIndex".as_bytes())
            .map(|sym| *sym);
        let nvmlUnitGetUnitInfo = __library
            .get("nvmlUnitGetUnitInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlUnitGetLedState = __library
            .get("nvmlUnitGetLedState".as_bytes())
            .map(|sym| *sym);
        let nvmlUnitGetPsuInfo = __library
            .get("nvmlUnitGetPsuInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlUnitGetTemperature = __library
            .get("nvmlUnitGetTemperature".as_bytes())
            .map(|sym| *sym);
        let nvmlUnitGetFanSpeedInfo = __library
            .get("nvmlUnitGetFanSpeedInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlUnitGetDevices = __library
            .get("nvmlUnitGetDevices".as_bytes())
            .map(|sym| *sym);
        let nvmlSystemGetHicVersion = __library
            .get("nvmlSystemGetHicVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetCount_v2 = __library
            .get("nvmlDeviceGetCount_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetAttributes_v2 = __library
            .get("nvmlDeviceGetAttributes_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetHandleByIndex_v2 = __library
            .get("nvmlDeviceGetHandleByIndex_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetHandleBySerial = __library
            .get("nvmlDeviceGetHandleBySerial".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetHandleByUUID = __library
            .get("nvmlDeviceGetHandleByUUID".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetHandleByPciBusId_v2 = __library
            .get("nvmlDeviceGetHandleByPciBusId_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetName = __library
            .get("nvmlDeviceGetName".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetBrand = __library
            .get("nvmlDeviceGetBrand".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetIndex = __library
            .get("nvmlDeviceGetIndex".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetSerial = __library
            .get("nvmlDeviceGetSerial".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMemoryAffinity = __library
            .get("nvmlDeviceGetMemoryAffinity".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetCpuAffinityWithinScope = __library
            .get("nvmlDeviceGetCpuAffinityWithinScope".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetCpuAffinity = __library
            .get("nvmlDeviceGetCpuAffinity".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetCpuAffinity = __library
            .get("nvmlDeviceSetCpuAffinity".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceClearCpuAffinity = __library
            .get("nvmlDeviceClearCpuAffinity".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetTopologyCommonAncestor = __library
            .get("nvmlDeviceGetTopologyCommonAncestor".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetTopologyNearestGpus = __library
            .get("nvmlDeviceGetTopologyNearestGpus".as_bytes())
            .map(|sym| *sym);
        let nvmlSystemGetTopologyGpuSet = __library
            .get("nvmlSystemGetTopologyGpuSet".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetP2PStatus = __library
            .get("nvmlDeviceGetP2PStatus".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetUUID = __library
            .get("nvmlDeviceGetUUID".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetMdevUUID = __library
            .get("nvmlVgpuInstanceGetMdevUUID".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMinorNumber = __library
            .get("nvmlDeviceGetMinorNumber".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetBoardPartNumber = __library
            .get("nvmlDeviceGetBoardPartNumber".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetInforomVersion = __library
            .get("nvmlDeviceGetInforomVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetInforomImageVersion = __library
            .get("nvmlDeviceGetInforomImageVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetInforomConfigurationChecksum = __library
            .get("nvmlDeviceGetInforomConfigurationChecksum".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceValidateInforom = __library
            .get("nvmlDeviceValidateInforom".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetDisplayMode = __library
            .get("nvmlDeviceGetDisplayMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetDisplayActive = __library
            .get("nvmlDeviceGetDisplayActive".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPersistenceMode = __library
            .get("nvmlDeviceGetPersistenceMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPciInfo_v3 = __library
            .get("nvmlDeviceGetPciInfo_v3".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMaxPcieLinkGeneration = __library
            .get("nvmlDeviceGetMaxPcieLinkGeneration".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMaxPcieLinkWidth = __library
            .get("nvmlDeviceGetMaxPcieLinkWidth".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetCurrPcieLinkGeneration = __library
            .get("nvmlDeviceGetCurrPcieLinkGeneration".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetCurrPcieLinkWidth = __library
            .get("nvmlDeviceGetCurrPcieLinkWidth".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPcieThroughput = __library
            .get("nvmlDeviceGetPcieThroughput".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPcieReplayCounter = __library
            .get("nvmlDeviceGetPcieReplayCounter".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetClockInfo = __library
            .get("nvmlDeviceGetClockInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMaxClockInfo = __library
            .get("nvmlDeviceGetMaxClockInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetApplicationsClock = __library
            .get("nvmlDeviceGetApplicationsClock".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetDefaultApplicationsClock = __library
            .get("nvmlDeviceGetDefaultApplicationsClock".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceResetApplicationsClocks = __library
            .get("nvmlDeviceResetApplicationsClocks".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetClock = __library
            .get("nvmlDeviceGetClock".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMaxCustomerBoostClock = __library
            .get("nvmlDeviceGetMaxCustomerBoostClock".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedMemoryClocks = __library
            .get("nvmlDeviceGetSupportedMemoryClocks".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedGraphicsClocks = __library
            .get("nvmlDeviceGetSupportedGraphicsClocks".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetAutoBoostedClocksEnabled = __library
            .get("nvmlDeviceGetAutoBoostedClocksEnabled".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetAutoBoostedClocksEnabled = __library
            .get("nvmlDeviceSetAutoBoostedClocksEnabled".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetDefaultAutoBoostedClocksEnabled = __library
            .get("nvmlDeviceSetDefaultAutoBoostedClocksEnabled".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetFanSpeed = __library
            .get("nvmlDeviceGetFanSpeed".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetFanSpeed_v2 = __library
            .get("nvmlDeviceGetFanSpeed_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetTemperature = __library
            .get("nvmlDeviceGetTemperature".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetTemperatureThreshold = __library
            .get("nvmlDeviceGetTemperatureThreshold".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPerformanceState = __library
            .get("nvmlDeviceGetPerformanceState".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetCurrentClocksThrottleReasons = __library
            .get("nvmlDeviceGetCurrentClocksThrottleReasons".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedClocksThrottleReasons = __library
            .get("nvmlDeviceGetSupportedClocksThrottleReasons".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPowerState = __library
            .get("nvmlDeviceGetPowerState".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementMode = __library
            .get("nvmlDeviceGetPowerManagementMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementLimit = __library
            .get("nvmlDeviceGetPowerManagementLimit".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementLimitConstraints = __library
            .get("nvmlDeviceGetPowerManagementLimitConstraints".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPowerManagementDefaultLimit = __library
            .get("nvmlDeviceGetPowerManagementDefaultLimit".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPowerUsage = __library
            .get("nvmlDeviceGetPowerUsage".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetTotalEnergyConsumption = __library
            .get("nvmlDeviceGetTotalEnergyConsumption".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetEnforcedPowerLimit = __library
            .get("nvmlDeviceGetEnforcedPowerLimit".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGpuOperationMode = __library
            .get("nvmlDeviceGetGpuOperationMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMemoryInfo = __library
            .get("nvmlDeviceGetMemoryInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetComputeMode = __library
            .get("nvmlDeviceGetComputeMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetCudaComputeCapability = __library
            .get("nvmlDeviceGetCudaComputeCapability".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetEccMode = __library
            .get("nvmlDeviceGetEccMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetBoardId = __library
            .get("nvmlDeviceGetBoardId".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMultiGpuBoard = __library
            .get("nvmlDeviceGetMultiGpuBoard".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetTotalEccErrors = __library
            .get("nvmlDeviceGetTotalEccErrors".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetDetailedEccErrors = __library
            .get("nvmlDeviceGetDetailedEccErrors".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMemoryErrorCounter = __library
            .get("nvmlDeviceGetMemoryErrorCounter".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetUtilizationRates = __library
            .get("nvmlDeviceGetUtilizationRates".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderUtilization = __library
            .get("nvmlDeviceGetEncoderUtilization".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderCapacity = __library
            .get("nvmlDeviceGetEncoderCapacity".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderStats = __library
            .get("nvmlDeviceGetEncoderStats".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetEncoderSessions = __library
            .get("nvmlDeviceGetEncoderSessions".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetDecoderUtilization = __library
            .get("nvmlDeviceGetDecoderUtilization".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetFBCStats = __library
            .get("nvmlDeviceGetFBCStats".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetFBCSessions = __library
            .get("nvmlDeviceGetFBCSessions".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetDriverModel = __library
            .get("nvmlDeviceGetDriverModel".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetVbiosVersion = __library
            .get("nvmlDeviceGetVbiosVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetBridgeChipInfo = __library
            .get("nvmlDeviceGetBridgeChipInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetComputeRunningProcesses_v2 = __library
            .get("nvmlDeviceGetComputeRunningProcesses_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGraphicsRunningProcesses_v2 = __library
            .get("nvmlDeviceGetGraphicsRunningProcesses_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceOnSameBoard = __library
            .get("nvmlDeviceOnSameBoard".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetAPIRestriction = __library
            .get("nvmlDeviceGetAPIRestriction".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetSamples = __library
            .get("nvmlDeviceGetSamples".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetBAR1MemoryInfo = __library
            .get("nvmlDeviceGetBAR1MemoryInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetViolationStatus = __library
            .get("nvmlDeviceGetViolationStatus".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingMode = __library
            .get("nvmlDeviceGetAccountingMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingStats = __library
            .get("nvmlDeviceGetAccountingStats".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingPids = __library
            .get("nvmlDeviceGetAccountingPids".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetAccountingBufferSize = __library
            .get("nvmlDeviceGetAccountingBufferSize".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPages = __library
            .get("nvmlDeviceGetRetiredPages".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPages_v2 = __library
            .get("nvmlDeviceGetRetiredPages_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetRetiredPagesPendingStatus = __library
            .get("nvmlDeviceGetRetiredPagesPendingStatus".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetRemappedRows = __library
            .get("nvmlDeviceGetRemappedRows".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetRowRemapperHistogram = __library
            .get("nvmlDeviceGetRowRemapperHistogram".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetArchitecture = __library
            .get("nvmlDeviceGetArchitecture".as_bytes())
            .map(|sym| *sym);
        let nvmlUnitSetLedState = __library
            .get("nvmlUnitSetLedState".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetPersistenceMode = __library
            .get("nvmlDeviceSetPersistenceMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetComputeMode = __library
            .get("nvmlDeviceSetComputeMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetEccMode = __library
            .get("nvmlDeviceSetEccMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceClearEccErrorCounts = __library
            .get("nvmlDeviceClearEccErrorCounts".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetDriverModel = __library
            .get("nvmlDeviceSetDriverModel".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetGpuLockedClocks = __library
            .get("nvmlDeviceSetGpuLockedClocks".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceResetGpuLockedClocks = __library
            .get("nvmlDeviceResetGpuLockedClocks".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetApplicationsClocks = __library
            .get("nvmlDeviceSetApplicationsClocks".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetPowerManagementLimit = __library
            .get("nvmlDeviceSetPowerManagementLimit".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetGpuOperationMode = __library
            .get("nvmlDeviceSetGpuOperationMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetAPIRestriction = __library
            .get("nvmlDeviceSetAPIRestriction".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetAccountingMode = __library
            .get("nvmlDeviceSetAccountingMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceClearAccountingPids = __library
            .get("nvmlDeviceClearAccountingPids".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkState = __library
            .get("nvmlDeviceGetNvLinkState".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkVersion = __library
            .get("nvmlDeviceGetNvLinkVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkCapability = __library
            .get("nvmlDeviceGetNvLinkCapability".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkRemotePciInfo_v2 = __library
            .get("nvmlDeviceGetNvLinkRemotePciInfo_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkErrorCounter = __library
            .get("nvmlDeviceGetNvLinkErrorCounter".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceResetNvLinkErrorCounters = __library
            .get("nvmlDeviceResetNvLinkErrorCounters".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetNvLinkUtilizationControl = __library
            .get("nvmlDeviceSetNvLinkUtilizationControl".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkUtilizationControl = __library
            .get("nvmlDeviceGetNvLinkUtilizationControl".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetNvLinkUtilizationCounter = __library
            .get("nvmlDeviceGetNvLinkUtilizationCounter".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceFreezeNvLinkUtilizationCounter = __library
            .get("nvmlDeviceFreezeNvLinkUtilizationCounter".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceResetNvLinkUtilizationCounter = __library
            .get("nvmlDeviceResetNvLinkUtilizationCounter".as_bytes())
            .map(|sym| *sym);
        let nvmlEventSetCreate = __library
            .get("nvmlEventSetCreate".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceRegisterEvents = __library
            .get("nvmlDeviceRegisterEvents".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedEventTypes = __library
            .get("nvmlDeviceGetSupportedEventTypes".as_bytes())
            .map(|sym| *sym);
        let nvmlEventSetWait_v2 = __library
            .get("nvmlEventSetWait_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlEventSetFree = __library.get("nvmlEventSetFree".as_bytes()).map(|sym| *sym);
        let nvmlDeviceModifyDrainState = __library
            .get("nvmlDeviceModifyDrainState".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceQueryDrainState = __library
            .get("nvmlDeviceQueryDrainState".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceRemoveGpu_v2 = __library
            .get("nvmlDeviceRemoveGpu_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceDiscoverGpus = __library
            .get("nvmlDeviceDiscoverGpus".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetFieldValues = __library
            .get("nvmlDeviceGetFieldValues".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetVirtualizationMode = __library
            .get("nvmlDeviceGetVirtualizationMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetHostVgpuMode = __library
            .get("nvmlDeviceGetHostVgpuMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetVirtualizationMode = __library
            .get("nvmlDeviceSetVirtualizationMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGridLicensableFeatures_v3 = __library
            .get("nvmlDeviceGetGridLicensableFeatures_v3".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetProcessUtilization = __library
            .get("nvmlDeviceGetProcessUtilization".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetSupportedVgpus = __library
            .get("nvmlDeviceGetSupportedVgpus".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetCreatableVgpus = __library
            .get("nvmlDeviceGetCreatableVgpus".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetClass = __library
            .get("nvmlVgpuTypeGetClass".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetName = __library
            .get("nvmlVgpuTypeGetName".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetGpuInstanceProfileId = __library
            .get("nvmlVgpuTypeGetGpuInstanceProfileId".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetDeviceID = __library
            .get("nvmlVgpuTypeGetDeviceID".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetFramebufferSize = __library
            .get("nvmlVgpuTypeGetFramebufferSize".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetNumDisplayHeads = __library
            .get("nvmlVgpuTypeGetNumDisplayHeads".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetResolution = __library
            .get("nvmlVgpuTypeGetResolution".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetLicense = __library
            .get("nvmlVgpuTypeGetLicense".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetFrameRateLimit = __library
            .get("nvmlVgpuTypeGetFrameRateLimit".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetMaxInstances = __library
            .get("nvmlVgpuTypeGetMaxInstances".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuTypeGetMaxInstancesPerVm = __library
            .get("nvmlVgpuTypeGetMaxInstancesPerVm".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetActiveVgpus = __library
            .get("nvmlDeviceGetActiveVgpus".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetVmID = __library
            .get("nvmlVgpuInstanceGetVmID".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetUUID = __library
            .get("nvmlVgpuInstanceGetUUID".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetVmDriverVersion = __library
            .get("nvmlVgpuInstanceGetVmDriverVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFbUsage = __library
            .get("nvmlVgpuInstanceGetFbUsage".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetLicenseStatus = __library
            .get("nvmlVgpuInstanceGetLicenseStatus".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetType = __library
            .get("nvmlVgpuInstanceGetType".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFrameRateLimit = __library
            .get("nvmlVgpuInstanceGetFrameRateLimit".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEccMode = __library
            .get("nvmlVgpuInstanceGetEccMode".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderCapacity = __library
            .get("nvmlVgpuInstanceGetEncoderCapacity".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceSetEncoderCapacity = __library
            .get("nvmlVgpuInstanceSetEncoderCapacity".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderStats = __library
            .get("nvmlVgpuInstanceGetEncoderStats".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetEncoderSessions = __library
            .get("nvmlVgpuInstanceGetEncoderSessions".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFBCStats = __library
            .get("nvmlVgpuInstanceGetFBCStats".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetFBCSessions = __library
            .get("nvmlVgpuInstanceGetFBCSessions".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetMetadata = __library
            .get("nvmlVgpuInstanceGetMetadata".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuMetadata = __library
            .get("nvmlDeviceGetVgpuMetadata".as_bytes())
            .map(|sym| *sym);
        let nvmlGetVgpuCompatibility = __library
            .get("nvmlGetVgpuCompatibility".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetPgpuMetadataString = __library
            .get("nvmlDeviceGetPgpuMetadataString".as_bytes())
            .map(|sym| *sym);
        let nvmlGetVgpuVersion = __library
            .get("nvmlGetVgpuVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlSetVgpuVersion = __library
            .get("nvmlSetVgpuVersion".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuUtilization = __library
            .get("nvmlDeviceGetVgpuUtilization".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetVgpuProcessUtilization = __library
            .get("nvmlDeviceGetVgpuProcessUtilization".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingMode = __library
            .get("nvmlVgpuInstanceGetAccountingMode".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingPids = __library
            .get("nvmlVgpuInstanceGetAccountingPids".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceGetAccountingStats = __library
            .get("nvmlVgpuInstanceGetAccountingStats".as_bytes())
            .map(|sym| *sym);
        let nvmlVgpuInstanceClearAccountingPids = __library
            .get("nvmlVgpuInstanceClearAccountingPids".as_bytes())
            .map(|sym| *sym);
        let nvmlGetBlacklistDeviceCount = __library
            .get("nvmlGetBlacklistDeviceCount".as_bytes())
            .map(|sym| *sym);
        let nvmlGetBlacklistDeviceInfoByIndex = __library
            .get("nvmlGetBlacklistDeviceInfoByIndex".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceSetMigMode = __library
            .get("nvmlDeviceSetMigMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMigMode = __library
            .get("nvmlDeviceGetMigMode".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceProfileInfo = __library
            .get("nvmlDeviceGetGpuInstanceProfileInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstancePossiblePlacements = __library
            .get("nvmlDeviceGetGpuInstancePossiblePlacements".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceRemainingCapacity = __library
            .get("nvmlDeviceGetGpuInstanceRemainingCapacity".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceCreateGpuInstance = __library
            .get("nvmlDeviceCreateGpuInstance".as_bytes())
            .map(|sym| *sym);
        let nvmlGpuInstanceDestroy = __library
            .get("nvmlGpuInstanceDestroy".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstances = __library
            .get("nvmlDeviceGetGpuInstances".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceById = __library
            .get("nvmlDeviceGetGpuInstanceById".as_bytes())
            .map(|sym| *sym);
        let nvmlGpuInstanceGetInfo = __library
            .get("nvmlGpuInstanceGetInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceProfileInfo = __library
            .get("nvmlGpuInstanceGetComputeInstanceProfileInfo".as_bytes())
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceRemainingCapacity = __library
            .get("nvmlGpuInstanceGetComputeInstanceRemainingCapacity".as_bytes())
            .map(|sym| *sym);
        let nvmlGpuInstanceCreateComputeInstance = __library
            .get("nvmlGpuInstanceCreateComputeInstance".as_bytes())
            .map(|sym| *sym);
        let nvmlComputeInstanceDestroy = __library
            .get("nvmlComputeInstanceDestroy".as_bytes())
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstances = __library
            .get("nvmlGpuInstanceGetComputeInstances".as_bytes())
            .map(|sym| *sym);
        let nvmlGpuInstanceGetComputeInstanceById = __library
            .get("nvmlGpuInstanceGetComputeInstanceById".as_bytes())
            .map(|sym| *sym);
        let nvmlComputeInstanceGetInfo_v2 = __library
            .get("nvmlComputeInstanceGetInfo_v2".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceIsMigDeviceHandle = __library
            .get("nvmlDeviceIsMigDeviceHandle".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetGpuInstanceId = __library
            .get("nvmlDeviceGetGpuInstanceId".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetComputeInstanceId = __library
            .get("nvmlDeviceGetComputeInstanceId".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMaxMigDeviceCount = __library
            .get("nvmlDeviceGetMaxMigDeviceCount".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetMigDeviceHandleByIndex = __library
            .get("nvmlDeviceGetMigDeviceHandleByIndex".as_bytes())
            .map(|sym| *sym);
        let nvmlDeviceGetDeviceHandleFromMigDeviceHandle = __library
            .get("nvmlDeviceGetDeviceHandleFromMigDeviceHandle".as_bytes())
            .map(|sym| *sym);
        Ok(nvml {
            __library,
            nvmlInit_v2,
            nvmlInitWithFlags,
            nvmlShutdown,
            nvmlErrorString,
            nvmlSystemGetDriverVersion,
            nvmlSystemGetNVMLVersion,
            nvmlSystemGetCudaDriverVersion,
            nvmlSystemGetCudaDriverVersion_v2,
            nvmlSystemGetProcessName,
            nvmlUnitGetCount,
            nvmlUnitGetHandleByIndex,
            nvmlUnitGetUnitInfo,
            nvmlUnitGetLedState,
            nvmlUnitGetPsuInfo,
            nvmlUnitGetTemperature,
            nvmlUnitGetFanSpeedInfo,
            nvmlUnitGetDevices,
            nvmlSystemGetHicVersion,
            nvmlDeviceGetCount_v2,
            nvmlDeviceGetAttributes_v2,
            nvmlDeviceGetHandleByIndex_v2,
            nvmlDeviceGetHandleBySerial,
            nvmlDeviceGetHandleByUUID,
            nvmlDeviceGetHandleByPciBusId_v2,
            nvmlDeviceGetName,
            nvmlDeviceGetBrand,
            nvmlDeviceGetIndex,
            nvmlDeviceGetSerial,
            nvmlDeviceGetMemoryAffinity,
            nvmlDeviceGetCpuAffinityWithinScope,
            nvmlDeviceGetCpuAffinity,
            nvmlDeviceSetCpuAffinity,
            nvmlDeviceClearCpuAffinity,
            nvmlDeviceGetTopologyCommonAncestor,
            nvmlDeviceGetTopologyNearestGpus,
            nvmlSystemGetTopologyGpuSet,
            nvmlDeviceGetP2PStatus,
            nvmlDeviceGetUUID,
            nvmlVgpuInstanceGetMdevUUID,
            nvmlDeviceGetMinorNumber,
            nvmlDeviceGetBoardPartNumber,
            nvmlDeviceGetInforomVersion,
            nvmlDeviceGetInforomImageVersion,
            nvmlDeviceGetInforomConfigurationChecksum,
            nvmlDeviceValidateInforom,
            nvmlDeviceGetDisplayMode,
            nvmlDeviceGetDisplayActive,
            nvmlDeviceGetPersistenceMode,
            nvmlDeviceGetPciInfo_v3,
            nvmlDeviceGetMaxPcieLinkGeneration,
            nvmlDeviceGetMaxPcieLinkWidth,
            nvmlDeviceGetCurrPcieLinkGeneration,
            nvmlDeviceGetCurrPcieLinkWidth,
            nvmlDeviceGetPcieThroughput,
            nvmlDeviceGetPcieReplayCounter,
            nvmlDeviceGetClockInfo,
            nvmlDeviceGetMaxClockInfo,
            nvmlDeviceGetApplicationsClock,
            nvmlDeviceGetDefaultApplicationsClock,
            nvmlDeviceResetApplicationsClocks,
            nvmlDeviceGetClock,
            nvmlDeviceGetMaxCustomerBoostClock,
            nvmlDeviceGetSupportedMemoryClocks,
            nvmlDeviceGetSupportedGraphicsClocks,
            nvmlDeviceGetAutoBoostedClocksEnabled,
            nvmlDeviceSetAutoBoostedClocksEnabled,
            nvmlDeviceSetDefaultAutoBoostedClocksEnabled,
            nvmlDeviceGetFanSpeed,
            nvmlDeviceGetFanSpeed_v2,
            nvmlDeviceGetTemperature,
            nvmlDeviceGetTemperatureThreshold,
            nvmlDeviceGetPerformanceState,
            nvmlDeviceGetCurrentClocksThrottleReasons,
            nvmlDeviceGetSupportedClocksThrottleReasons,
            nvmlDeviceGetPowerState,
            nvmlDeviceGetPowerManagementMode,
            nvmlDeviceGetPowerManagementLimit,
            nvmlDeviceGetPowerManagementLimitConstraints,
            nvmlDeviceGetPowerManagementDefaultLimit,
            nvmlDeviceGetPowerUsage,
            nvmlDeviceGetTotalEnergyConsumption,
            nvmlDeviceGetEnforcedPowerLimit,
            nvmlDeviceGetGpuOperationMode,
            nvmlDeviceGetMemoryInfo,
            nvmlDeviceGetComputeMode,
            nvmlDeviceGetCudaComputeCapability,
            nvmlDeviceGetEccMode,
            nvmlDeviceGetBoardId,
            nvmlDeviceGetMultiGpuBoard,
            nvmlDeviceGetTotalEccErrors,
            nvmlDeviceGetDetailedEccErrors,
            nvmlDeviceGetMemoryErrorCounter,
            nvmlDeviceGetUtilizationRates,
            nvmlDeviceGetEncoderUtilization,
            nvmlDeviceGetEncoderCapacity,
            nvmlDeviceGetEncoderStats,
            nvmlDeviceGetEncoderSessions,
            nvmlDeviceGetDecoderUtilization,
            nvmlDeviceGetFBCStats,
            nvmlDeviceGetFBCSessions,
            nvmlDeviceGetDriverModel,
            nvmlDeviceGetVbiosVersion,
            nvmlDeviceGetBridgeChipInfo,
            nvmlDeviceGetComputeRunningProcesses_v2,
            nvmlDeviceGetGraphicsRunningProcesses_v2,
            nvmlDeviceOnSameBoard,
            nvmlDeviceGetAPIRestriction,
            nvmlDeviceGetSamples,
            nvmlDeviceGetBAR1MemoryInfo,
            nvmlDeviceGetViolationStatus,
            nvmlDeviceGetAccountingMode,
            nvmlDeviceGetAccountingStats,
            nvmlDeviceGetAccountingPids,
            nvmlDeviceGetAccountingBufferSize,
            nvmlDeviceGetRetiredPages,
            nvmlDeviceGetRetiredPages_v2,
            nvmlDeviceGetRetiredPagesPendingStatus,
            nvmlDeviceGetRemappedRows,
            nvmlDeviceGetRowRemapperHistogram,
            nvmlDeviceGetArchitecture,
            nvmlUnitSetLedState,
            nvmlDeviceSetPersistenceMode,
            nvmlDeviceSetComputeMode,
            nvmlDeviceSetEccMode,
            nvmlDeviceClearEccErrorCounts,
            nvmlDeviceSetDriverModel,
            nvmlDeviceSetGpuLockedClocks,
            nvmlDeviceResetGpuLockedClocks,
            nvmlDeviceSetApplicationsClocks,
            nvmlDeviceSetPowerManagementLimit,
            nvmlDeviceSetGpuOperationMode,
            nvmlDeviceSetAPIRestriction,
            nvmlDeviceSetAccountingMode,
            nvmlDeviceClearAccountingPids,
            nvmlDeviceGetNvLinkState,
            nvmlDeviceGetNvLinkVersion,
            nvmlDeviceGetNvLinkCapability,
            nvmlDeviceGetNvLinkRemotePciInfo_v2,
            nvmlDeviceGetNvLinkErrorCounter,
            nvmlDeviceResetNvLinkErrorCounters,
            nvmlDeviceSetNvLinkUtilizationControl,
            nvmlDeviceGetNvLinkUtilizationControl,
            nvmlDeviceGetNvLinkUtilizationCounter,
            nvmlDeviceFreezeNvLinkUtilizationCounter,
            nvmlDeviceResetNvLinkUtilizationCounter,
            nvmlEventSetCreate,
            nvmlDeviceRegisterEvents,
            nvmlDeviceGetSupportedEventTypes,
            nvmlEventSetWait_v2,
            nvmlEventSetFree,
            nvmlDeviceModifyDrainState,
            nvmlDeviceQueryDrainState,
            nvmlDeviceRemoveGpu_v2,
            nvmlDeviceDiscoverGpus,
            nvmlDeviceGetFieldValues,
            nvmlDeviceGetVirtualizationMode,
            nvmlDeviceGetHostVgpuMode,
            nvmlDeviceSetVirtualizationMode,
            nvmlDeviceGetGridLicensableFeatures_v3,
            nvmlDeviceGetProcessUtilization,
            nvmlDeviceGetSupportedVgpus,
            nvmlDeviceGetCreatableVgpus,
            nvmlVgpuTypeGetClass,
            nvmlVgpuTypeGetName,
            nvmlVgpuTypeGetGpuInstanceProfileId,
            nvmlVgpuTypeGetDeviceID,
            nvmlVgpuTypeGetFramebufferSize,
            nvmlVgpuTypeGetNumDisplayHeads,
            nvmlVgpuTypeGetResolution,
            nvmlVgpuTypeGetLicense,
            nvmlVgpuTypeGetFrameRateLimit,
            nvmlVgpuTypeGetMaxInstances,
            nvmlVgpuTypeGetMaxInstancesPerVm,
            nvmlDeviceGetActiveVgpus,
            nvmlVgpuInstanceGetVmID,
            nvmlVgpuInstanceGetUUID,
            nvmlVgpuInstanceGetVmDriverVersion,
            nvmlVgpuInstanceGetFbUsage,
            nvmlVgpuInstanceGetLicenseStatus,
            nvmlVgpuInstanceGetType,
            nvmlVgpuInstanceGetFrameRateLimit,
            nvmlVgpuInstanceGetEccMode,
            nvmlVgpuInstanceGetEncoderCapacity,
            nvmlVgpuInstanceSetEncoderCapacity,
            nvmlVgpuInstanceGetEncoderStats,
            nvmlVgpuInstanceGetEncoderSessions,
            nvmlVgpuInstanceGetFBCStats,
            nvmlVgpuInstanceGetFBCSessions,
            nvmlVgpuInstanceGetMetadata,
            nvmlDeviceGetVgpuMetadata,
            nvmlGetVgpuCompatibility,
            nvmlDeviceGetPgpuMetadataString,
            nvmlGetVgpuVersion,
            nvmlSetVgpuVersion,
            nvmlDeviceGetVgpuUtilization,
            nvmlDeviceGetVgpuProcessUtilization,
            nvmlVgpuInstanceGetAccountingMode,
            nvmlVgpuInstanceGetAccountingPids,
            nvmlVgpuInstanceGetAccountingStats,
            nvmlVgpuInstanceClearAccountingPids,
            nvmlGetBlacklistDeviceCount,
            nvmlGetBlacklistDeviceInfoByIndex,
            nvmlDeviceSetMigMode,
            nvmlDeviceGetMigMode,
            nvmlDeviceGetGpuInstanceProfileInfo,
            nvmlDeviceGetGpuInstancePossiblePlacements,
            nvmlDeviceGetGpuInstanceRemainingCapacity,
            nvmlDeviceCreateGpuInstance,
            nvmlGpuInstanceDestroy,
            nvmlDeviceGetGpuInstances,
            nvmlDeviceGetGpuInstanceById,
            nvmlGpuInstanceGetInfo,
            nvmlGpuInstanceGetComputeInstanceProfileInfo,
            nvmlGpuInstanceGetComputeInstanceRemainingCapacity,
            nvmlGpuInstanceCreateComputeInstance,
            nvmlComputeInstanceDestroy,
            nvmlGpuInstanceGetComputeInstances,
            nvmlGpuInstanceGetComputeInstanceById,
            nvmlComputeInstanceGetInfo_v2,
            nvmlDeviceIsMigDeviceHandle,
            nvmlDeviceGetGpuInstanceId,
            nvmlDeviceGetComputeInstanceId,
            nvmlDeviceGetMaxMigDeviceCount,
            nvmlDeviceGetMigDeviceHandleByIndex,
            nvmlDeviceGetDeviceHandleFromMigDeviceHandle,
        })
    }
    pub unsafe fn nvmlInit_v2(&self) -> nvmlReturn_t {
        let sym = self
            .nvmlInit_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn nvmlInitWithFlags(&self, flags: raw::c_uint) -> nvmlReturn_t {
        let sym = self
            .nvmlInitWithFlags
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(flags)
    }
    pub unsafe fn nvmlShutdown(&self) -> nvmlReturn_t {
        let sym = self
            .nvmlShutdown
            .as_ref()
            .expect("Expected function, got error.");
        (sym)()
    }
    pub unsafe fn nvmlErrorString(&self, result: nvmlReturn_t) -> *const raw::c_char {
        let sym = self
            .nvmlErrorString
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(result)
    }
    pub unsafe fn nvmlSystemGetDriverVersion(
        &self,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlSystemGetDriverVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(version, length)
    }
    pub unsafe fn nvmlSystemGetNVMLVersion(
        &self,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlSystemGetNVMLVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(version, length)
    }
    pub unsafe fn nvmlSystemGetCudaDriverVersion(
        &self,
        cudaDriverVersion: *mut raw::c_int,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlSystemGetCudaDriverVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(cudaDriverVersion)
    }
    pub unsafe fn nvmlSystemGetCudaDriverVersion_v2(
        &self,
        cudaDriverVersion: *mut raw::c_int,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlSystemGetCudaDriverVersion_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(cudaDriverVersion)
    }
    pub unsafe fn nvmlSystemGetProcessName(
        &self,
        pid: raw::c_uint,
        name: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlSystemGetProcessName
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(pid, name, length)
    }
    pub unsafe fn nvmlUnitGetCount(&self, unitCount: *mut raw::c_uint) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitGetCount
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(unitCount)
    }
    pub unsafe fn nvmlUnitGetHandleByIndex(
        &self,
        index: raw::c_uint,
        unit: *mut nvmlUnit_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitGetHandleByIndex
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(index, unit)
    }
    pub unsafe fn nvmlUnitGetUnitInfo(
        &self,
        unit: nvmlUnit_t,
        info: *mut nvmlUnitInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitGetUnitInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(unit, info)
    }
    pub unsafe fn nvmlUnitGetLedState(
        &self,
        unit: nvmlUnit_t,
        state: *mut nvmlLedState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitGetLedState
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(unit, state)
    }
    pub unsafe fn nvmlUnitGetPsuInfo(
        &self,
        unit: nvmlUnit_t,
        psu: *mut nvmlPSUInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitGetPsuInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(unit, psu)
    }
    pub unsafe fn nvmlUnitGetTemperature(
        &self,
        unit: nvmlUnit_t,
        type_: raw::c_uint,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitGetTemperature
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(unit, type_, temp)
    }
    pub unsafe fn nvmlUnitGetFanSpeedInfo(
        &self,
        unit: nvmlUnit_t,
        fanSpeeds: *mut nvmlUnitFanSpeeds_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitGetFanSpeedInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(unit, fanSpeeds)
    }
    pub unsafe fn nvmlUnitGetDevices(
        &self,
        unit: nvmlUnit_t,
        deviceCount: *mut raw::c_uint,
        devices: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitGetDevices
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(unit, deviceCount, devices)
    }
    pub unsafe fn nvmlSystemGetHicVersion(
        &self,
        hwbcCount: *mut raw::c_uint,
        hwbcEntries: *mut nvmlHwbcEntry_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlSystemGetHicVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(hwbcCount, hwbcEntries)
    }
    pub unsafe fn nvmlDeviceGetCount_v2(&self, deviceCount: *mut raw::c_uint) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetCount_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(deviceCount)
    }
    pub unsafe fn nvmlDeviceGetAttributes_v2(
        &self,
        device: nvmlDevice_t,
        attributes: *mut nvmlDeviceAttributes_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetAttributes_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, attributes)
    }
    pub unsafe fn nvmlDeviceGetHandleByIndex_v2(
        &self,
        index: raw::c_uint,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetHandleByIndex_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(index, device)
    }
    pub unsafe fn nvmlDeviceGetHandleBySerial(
        &self,
        serial: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetHandleBySerial
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(serial, device)
    }
    pub unsafe fn nvmlDeviceGetHandleByUUID(
        &self,
        uuid: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetHandleByUUID
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(uuid, device)
    }
    pub unsafe fn nvmlDeviceGetHandleByPciBusId_v2(
        &self,
        pciBusId: *const raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetHandleByPciBusId_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(pciBusId, device)
    }
    pub unsafe fn nvmlDeviceGetName(
        &self,
        device: nvmlDevice_t,
        name: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetName
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, name, length)
    }
    pub unsafe fn nvmlDeviceGetBrand(
        &self,
        device: nvmlDevice_t,
        type_: *mut nvmlBrandType_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetBrand
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, type_)
    }
    pub unsafe fn nvmlDeviceGetIndex(
        &self,
        device: nvmlDevice_t,
        index: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetIndex
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, index)
    }
    pub unsafe fn nvmlDeviceGetSerial(
        &self,
        device: nvmlDevice_t,
        serial: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetSerial
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, serial, length)
    }
    pub unsafe fn nvmlDeviceGetMemoryAffinity(
        &self,
        device: nvmlDevice_t,
        nodeSetSize: raw::c_uint,
        nodeSet: *mut raw::c_ulong,
        scope: nvmlAffinityScope_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMemoryAffinity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, nodeSetSize, nodeSet, scope)
    }
    pub unsafe fn nvmlDeviceGetCpuAffinityWithinScope(
        &self,
        device: nvmlDevice_t,
        cpuSetSize: raw::c_uint,
        cpuSet: *mut raw::c_ulong,
        scope: nvmlAffinityScope_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetCpuAffinityWithinScope
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, cpuSetSize, cpuSet, scope)
    }
    pub unsafe fn nvmlDeviceGetCpuAffinity(
        &self,
        device: nvmlDevice_t,
        cpuSetSize: raw::c_uint,
        cpuSet: *mut raw::c_ulong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetCpuAffinity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, cpuSetSize, cpuSet)
    }
    pub unsafe fn nvmlDeviceSetCpuAffinity(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetCpuAffinity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device)
    }
    pub unsafe fn nvmlDeviceClearCpuAffinity(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceClearCpuAffinity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device)
    }
    pub unsafe fn nvmlDeviceGetTopologyCommonAncestor(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        pathInfo: *mut nvmlGpuTopologyLevel_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetTopologyCommonAncestor
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device1, device2, pathInfo)
    }
    pub unsafe fn nvmlDeviceGetTopologyNearestGpus(
        &self,
        device: nvmlDevice_t,
        level: nvmlGpuTopologyLevel_t,
        count: *mut raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetTopologyNearestGpus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, level, count, deviceArray)
    }
    pub unsafe fn nvmlSystemGetTopologyGpuSet(
        &self,
        cpuNumber: raw::c_uint,
        count: *mut raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlSystemGetTopologyGpuSet
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(cpuNumber, count, deviceArray)
    }
    pub unsafe fn nvmlDeviceGetP2PStatus(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        p2pIndex: nvmlGpuP2PCapsIndex_t,
        p2pStatus: *mut nvmlGpuP2PStatus_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetP2PStatus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device1, device2, p2pIndex, p2pStatus)
    }
    pub unsafe fn nvmlDeviceGetUUID(
        &self,
        device: nvmlDevice_t,
        uuid: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetUUID
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, uuid, length)
    }
    pub unsafe fn nvmlVgpuInstanceGetMdevUUID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        mdevUuid: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetMdevUUID
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, mdevUuid, size)
    }
    pub unsafe fn nvmlDeviceGetMinorNumber(
        &self,
        device: nvmlDevice_t,
        minorNumber: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMinorNumber
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, minorNumber)
    }
    pub unsafe fn nvmlDeviceGetBoardPartNumber(
        &self,
        device: nvmlDevice_t,
        partNumber: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetBoardPartNumber
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, partNumber, length)
    }
    pub unsafe fn nvmlDeviceGetInforomVersion(
        &self,
        device: nvmlDevice_t,
        object: nvmlInforomObject_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetInforomVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, object, version, length)
    }
    pub unsafe fn nvmlDeviceGetInforomImageVersion(
        &self,
        device: nvmlDevice_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetInforomImageVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, version, length)
    }
    pub unsafe fn nvmlDeviceGetInforomConfigurationChecksum(
        &self,
        device: nvmlDevice_t,
        checksum: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetInforomConfigurationChecksum
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, checksum)
    }
    pub unsafe fn nvmlDeviceValidateInforom(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceValidateInforom
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device)
    }
    pub unsafe fn nvmlDeviceGetDisplayMode(
        &self,
        device: nvmlDevice_t,
        display: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetDisplayMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, display)
    }
    pub unsafe fn nvmlDeviceGetDisplayActive(
        &self,
        device: nvmlDevice_t,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetDisplayActive
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, isActive)
    }
    pub unsafe fn nvmlDeviceGetPersistenceMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPersistenceMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode)
    }
    pub unsafe fn nvmlDeviceGetPciInfo_v3(
        &self,
        device: nvmlDevice_t,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPciInfo_v3
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pci)
    }
    pub unsafe fn nvmlDeviceGetMaxPcieLinkGeneration(
        &self,
        device: nvmlDevice_t,
        maxLinkGen: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMaxPcieLinkGeneration
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, maxLinkGen)
    }
    pub unsafe fn nvmlDeviceGetMaxPcieLinkWidth(
        &self,
        device: nvmlDevice_t,
        maxLinkWidth: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMaxPcieLinkWidth
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, maxLinkWidth)
    }
    pub unsafe fn nvmlDeviceGetCurrPcieLinkGeneration(
        &self,
        device: nvmlDevice_t,
        currLinkGen: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetCurrPcieLinkGeneration
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, currLinkGen)
    }
    pub unsafe fn nvmlDeviceGetCurrPcieLinkWidth(
        &self,
        device: nvmlDevice_t,
        currLinkWidth: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetCurrPcieLinkWidth
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, currLinkWidth)
    }
    pub unsafe fn nvmlDeviceGetPcieThroughput(
        &self,
        device: nvmlDevice_t,
        counter: nvmlPcieUtilCounter_t,
        value: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPcieThroughput
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, counter, value)
    }
    pub unsafe fn nvmlDeviceGetPcieReplayCounter(
        &self,
        device: nvmlDevice_t,
        value: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPcieReplayCounter
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, value)
    }
    pub unsafe fn nvmlDeviceGetClockInfo(
        &self,
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetClockInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, type_, clock)
    }
    pub unsafe fn nvmlDeviceGetMaxClockInfo(
        &self,
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMaxClockInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, type_, clock)
    }
    pub unsafe fn nvmlDeviceGetApplicationsClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetApplicationsClock
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetDefaultApplicationsClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetDefaultApplicationsClock
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceResetApplicationsClocks(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceResetApplicationsClocks
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device)
    }
    pub unsafe fn nvmlDeviceGetClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockId: nvmlClockId_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetClock
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, clockType, clockId, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetMaxCustomerBoostClock(
        &self,
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMaxCustomerBoostClock
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, clockType, clockMHz)
    }
    pub unsafe fn nvmlDeviceGetSupportedMemoryClocks(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
        clocksMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetSupportedMemoryClocks
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, count, clocksMHz)
    }
    pub unsafe fn nvmlDeviceGetSupportedGraphicsClocks(
        &self,
        device: nvmlDevice_t,
        memoryClockMHz: raw::c_uint,
        count: *mut raw::c_uint,
        clocksMHz: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetSupportedGraphicsClocks
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, memoryClockMHz, count, clocksMHz)
    }
    pub unsafe fn nvmlDeviceGetAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        isEnabled: *mut nvmlEnableState_t,
        defaultIsEnabled: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, isEnabled, defaultIsEnabled)
    }
    pub unsafe fn nvmlDeviceSetAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, enabled)
    }
    pub unsafe fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(
        &self,
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
        flags: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetDefaultAutoBoostedClocksEnabled
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, enabled, flags)
    }
    pub unsafe fn nvmlDeviceGetFanSpeed(
        &self,
        device: nvmlDevice_t,
        speed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetFanSpeed
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, speed)
    }
    pub unsafe fn nvmlDeviceGetFanSpeed_v2(
        &self,
        device: nvmlDevice_t,
        fan: raw::c_uint,
        speed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetFanSpeed_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, fan, speed)
    }
    pub unsafe fn nvmlDeviceGetTemperature(
        &self,
        device: nvmlDevice_t,
        sensorType: nvmlTemperatureSensors_t,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetTemperature
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, sensorType, temp)
    }
    pub unsafe fn nvmlDeviceGetTemperatureThreshold(
        &self,
        device: nvmlDevice_t,
        thresholdType: nvmlTemperatureThresholds_t,
        temp: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetTemperatureThreshold
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, thresholdType, temp)
    }
    pub unsafe fn nvmlDeviceGetPerformanceState(
        &self,
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPerformanceState
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pState)
    }
    pub unsafe fn nvmlDeviceGetCurrentClocksThrottleReasons(
        &self,
        device: nvmlDevice_t,
        clocksThrottleReasons: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetCurrentClocksThrottleReasons
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, clocksThrottleReasons)
    }
    pub unsafe fn nvmlDeviceGetSupportedClocksThrottleReasons(
        &self,
        device: nvmlDevice_t,
        supportedClocksThrottleReasons: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetSupportedClocksThrottleReasons
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, supportedClocksThrottleReasons)
    }
    pub unsafe fn nvmlDeviceGetPowerState(
        &self,
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPowerState
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pState)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPowerManagementMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementLimit(
        &self,
        device: nvmlDevice_t,
        limit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPowerManagementLimit
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, limit)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementLimitConstraints(
        &self,
        device: nvmlDevice_t,
        minLimit: *mut raw::c_uint,
        maxLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPowerManagementLimitConstraints
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, minLimit, maxLimit)
    }
    pub unsafe fn nvmlDeviceGetPowerManagementDefaultLimit(
        &self,
        device: nvmlDevice_t,
        defaultLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPowerManagementDefaultLimit
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, defaultLimit)
    }
    pub unsafe fn nvmlDeviceGetPowerUsage(
        &self,
        device: nvmlDevice_t,
        power: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPowerUsage
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, power)
    }
    pub unsafe fn nvmlDeviceGetTotalEnergyConsumption(
        &self,
        device: nvmlDevice_t,
        energy: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetTotalEnergyConsumption
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, energy)
    }
    pub unsafe fn nvmlDeviceGetEnforcedPowerLimit(
        &self,
        device: nvmlDevice_t,
        limit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetEnforcedPowerLimit
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, limit)
    }
    pub unsafe fn nvmlDeviceGetGpuOperationMode(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlGpuOperationMode_t,
        pending: *mut nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGpuOperationMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetMemoryInfo(
        &self,
        device: nvmlDevice_t,
        memory: *mut nvmlMemory_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMemoryInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, memory)
    }
    pub unsafe fn nvmlDeviceGetComputeMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlComputeMode_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetComputeMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode)
    }
    pub unsafe fn nvmlDeviceGetCudaComputeCapability(
        &self,
        device: nvmlDevice_t,
        major: *mut raw::c_int,
        minor: *mut raw::c_int,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetCudaComputeCapability
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, major, minor)
    }
    pub unsafe fn nvmlDeviceGetEccMode(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlEnableState_t,
        pending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetEccMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetBoardId(
        &self,
        device: nvmlDevice_t,
        boardId: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetBoardId
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, boardId)
    }
    pub unsafe fn nvmlDeviceGetMultiGpuBoard(
        &self,
        device: nvmlDevice_t,
        multiGpuBool: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMultiGpuBoard
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, multiGpuBool)
    }
    pub unsafe fn nvmlDeviceGetTotalEccErrors(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetTotalEccErrors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, errorType, counterType, eccCounts)
    }
    pub unsafe fn nvmlDeviceGetDetailedEccErrors(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut nvmlEccErrorCounts_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetDetailedEccErrors
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, errorType, counterType, eccCounts)
    }
    pub unsafe fn nvmlDeviceGetMemoryErrorCounter(
        &self,
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        locationType: nvmlMemoryLocation_t,
        count: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMemoryErrorCounter
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, errorType, counterType, locationType, count)
    }
    pub unsafe fn nvmlDeviceGetUtilizationRates(
        &self,
        device: nvmlDevice_t,
        utilization: *mut nvmlUtilization_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetUtilizationRates
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, utilization)
    }
    pub unsafe fn nvmlDeviceGetEncoderUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut raw::c_uint,
        samplingPeriodUs: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetEncoderUtilization
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, utilization, samplingPeriodUs)
    }
    pub unsafe fn nvmlDeviceGetEncoderCapacity(
        &self,
        device: nvmlDevice_t,
        encoderQueryType: nvmlEncoderType_t,
        encoderCapacity: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, encoderQueryType, encoderCapacity)
    }
    pub unsafe fn nvmlDeviceGetEncoderStats(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        averageFps: *mut raw::c_uint,
        averageLatency: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetEncoderStats
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, sessionCount, averageFps, averageLatency)
    }
    pub unsafe fn nvmlDeviceGetEncoderSessions(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        sessionInfos: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetEncoderSessions
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, sessionCount, sessionInfos)
    }
    pub unsafe fn nvmlDeviceGetDecoderUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut raw::c_uint,
        samplingPeriodUs: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetDecoderUtilization
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, utilization, samplingPeriodUs)
    }
    pub unsafe fn nvmlDeviceGetFBCStats(
        &self,
        device: nvmlDevice_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetFBCStats
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, fbcStats)
    }
    pub unsafe fn nvmlDeviceGetFBCSessions(
        &self,
        device: nvmlDevice_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetFBCSessions
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, sessionCount, sessionInfo)
    }
    pub unsafe fn nvmlDeviceGetDriverModel(
        &self,
        device: nvmlDevice_t,
        current: *mut nvmlDriverModel_t,
        pending: *mut nvmlDriverModel_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetDriverModel
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, current, pending)
    }
    pub unsafe fn nvmlDeviceGetVbiosVersion(
        &self,
        device: nvmlDevice_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetVbiosVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, version, length)
    }
    pub unsafe fn nvmlDeviceGetBridgeChipInfo(
        &self,
        device: nvmlDevice_t,
        bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetBridgeChipInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, bridgeHierarchy)
    }
    pub unsafe fn nvmlDeviceGetComputeRunningProcesses_v2(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetComputeRunningProcesses_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, infoCount, infos)
    }
    pub unsafe fn nvmlDeviceGetGraphicsRunningProcesses_v2(
        &self,
        device: nvmlDevice_t,
        infoCount: *mut raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGraphicsRunningProcesses_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, infoCount, infos)
    }
    pub unsafe fn nvmlDeviceOnSameBoard(
        &self,
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        onSameBoard: *mut raw::c_int,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceOnSameBoard
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device1, device2, onSameBoard)
    }
    pub unsafe fn nvmlDeviceGetAPIRestriction(
        &self,
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetAPIRestriction
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, apiType, isRestricted)
    }
    pub unsafe fn nvmlDeviceGetSamples(
        &self,
        device: nvmlDevice_t,
        type_: nvmlSamplingType_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        sampleCount: *mut raw::c_uint,
        samples: *mut nvmlSample_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetSamples
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            device,
            type_,
            lastSeenTimeStamp,
            sampleValType,
            sampleCount,
            samples,
        )
    }
    pub unsafe fn nvmlDeviceGetBAR1MemoryInfo(
        &self,
        device: nvmlDevice_t,
        bar1Memory: *mut nvmlBAR1Memory_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetBAR1MemoryInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, bar1Memory)
    }
    pub unsafe fn nvmlDeviceGetViolationStatus(
        &self,
        device: nvmlDevice_t,
        perfPolicyType: nvmlPerfPolicyType_t,
        violTime: *mut nvmlViolationTime_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetViolationStatus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, perfPolicyType, violTime)
    }
    pub unsafe fn nvmlDeviceGetAccountingMode(
        &self,
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetAccountingMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode)
    }
    pub unsafe fn nvmlDeviceGetAccountingStats(
        &self,
        device: nvmlDevice_t,
        pid: raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetAccountingStats
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pid, stats)
    }
    pub unsafe fn nvmlDeviceGetAccountingPids(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
        pids: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetAccountingPids
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, count, pids)
    }
    pub unsafe fn nvmlDeviceGetAccountingBufferSize(
        &self,
        device: nvmlDevice_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetAccountingBufferSize
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, bufferSize)
    }
    pub unsafe fn nvmlDeviceGetRetiredPages(
        &self,
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut raw::c_uint,
        addresses: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetRetiredPages
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, cause, pageCount, addresses)
    }
    pub unsafe fn nvmlDeviceGetRetiredPages_v2(
        &self,
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut raw::c_uint,
        addresses: *mut raw::c_ulonglong,
        timestamps: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetRetiredPages_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, cause, pageCount, addresses, timestamps)
    }
    pub unsafe fn nvmlDeviceGetRetiredPagesPendingStatus(
        &self,
        device: nvmlDevice_t,
        isPending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetRetiredPagesPendingStatus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, isPending)
    }
    pub unsafe fn nvmlDeviceGetRemappedRows(
        &self,
        device: nvmlDevice_t,
        corrRows: *mut raw::c_uint,
        uncRows: *mut raw::c_uint,
        isPending: *mut raw::c_uint,
        failureOccurred: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetRemappedRows
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, corrRows, uncRows, isPending, failureOccurred)
    }
    pub unsafe fn nvmlDeviceGetRowRemapperHistogram(
        &self,
        device: nvmlDevice_t,
        values: *mut nvmlRowRemapperHistogramValues_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetRowRemapperHistogram
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, values)
    }
    pub unsafe fn nvmlDeviceGetArchitecture(
        &self,
        device: nvmlDevice_t,
        arch: *mut nvmlDeviceArchitecture_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetArchitecture
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, arch)
    }
    pub unsafe fn nvmlUnitSetLedState(
        &self,
        unit: nvmlUnit_t,
        color: nvmlLedColor_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlUnitSetLedState
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(unit, color)
    }
    pub unsafe fn nvmlDeviceSetPersistenceMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetPersistenceMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode)
    }
    pub unsafe fn nvmlDeviceSetComputeMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlComputeMode_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetComputeMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode)
    }
    pub unsafe fn nvmlDeviceSetEccMode(
        &self,
        device: nvmlDevice_t,
        ecc: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetEccMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, ecc)
    }
    pub unsafe fn nvmlDeviceClearEccErrorCounts(
        &self,
        device: nvmlDevice_t,
        counterType: nvmlEccCounterType_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceClearEccErrorCounts
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, counterType)
    }
    pub unsafe fn nvmlDeviceSetDriverModel(
        &self,
        device: nvmlDevice_t,
        driverModel: nvmlDriverModel_t,
        flags: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetDriverModel
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, driverModel, flags)
    }
    pub unsafe fn nvmlDeviceSetGpuLockedClocks(
        &self,
        device: nvmlDevice_t,
        minGpuClockMHz: raw::c_uint,
        maxGpuClockMHz: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetGpuLockedClocks
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, minGpuClockMHz, maxGpuClockMHz)
    }
    pub unsafe fn nvmlDeviceResetGpuLockedClocks(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceResetGpuLockedClocks
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device)
    }
    pub unsafe fn nvmlDeviceSetApplicationsClocks(
        &self,
        device: nvmlDevice_t,
        memClockMHz: raw::c_uint,
        graphicsClockMHz: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetApplicationsClocks
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, memClockMHz, graphicsClockMHz)
    }
    pub unsafe fn nvmlDeviceSetPowerManagementLimit(
        &self,
        device: nvmlDevice_t,
        limit: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetPowerManagementLimit
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, limit)
    }
    pub unsafe fn nvmlDeviceSetGpuOperationMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetGpuOperationMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode)
    }
    pub unsafe fn nvmlDeviceSetAPIRestriction(
        &self,
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetAPIRestriction
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, apiType, isRestricted)
    }
    pub unsafe fn nvmlDeviceSetAccountingMode(
        &self,
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetAccountingMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode)
    }
    pub unsafe fn nvmlDeviceClearAccountingPids(&self, device: nvmlDevice_t) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceClearAccountingPids
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device)
    }
    pub unsafe fn nvmlDeviceGetNvLinkState(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetNvLinkState
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, isActive)
    }
    pub unsafe fn nvmlDeviceGetNvLinkVersion(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        version: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetNvLinkVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, version)
    }
    pub unsafe fn nvmlDeviceGetNvLinkCapability(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        capability: nvmlNvLinkCapability_t,
        capResult: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetNvLinkCapability
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, capability, capResult)
    }
    pub unsafe fn nvmlDeviceGetNvLinkRemotePciInfo_v2(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetNvLinkRemotePciInfo_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, pci)
    }
    pub unsafe fn nvmlDeviceGetNvLinkErrorCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: nvmlNvLinkErrorCounter_t,
        counterValue: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetNvLinkErrorCounter
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, counter, counterValue)
    }
    pub unsafe fn nvmlDeviceResetNvLinkErrorCounters(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceResetNvLinkErrorCounters
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link)
    }
    pub unsafe fn nvmlDeviceSetNvLinkUtilizationControl(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
        reset: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetNvLinkUtilizationControl
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, counter, control, reset)
    }
    pub unsafe fn nvmlDeviceGetNvLinkUtilizationControl(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetNvLinkUtilizationControl
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, counter, control)
    }
    pub unsafe fn nvmlDeviceGetNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        rxcounter: *mut raw::c_ulonglong,
        txcounter: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, counter, rxcounter, txcounter)
    }
    pub unsafe fn nvmlDeviceFreezeNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
        freeze: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceFreezeNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, counter, freeze)
    }
    pub unsafe fn nvmlDeviceResetNvLinkUtilizationCounter(
        &self,
        device: nvmlDevice_t,
        link: raw::c_uint,
        counter: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceResetNvLinkUtilizationCounter
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, link, counter)
    }
    pub unsafe fn nvmlEventSetCreate(&self, set: *mut nvmlEventSet_t) -> nvmlReturn_t {
        let sym = self
            .nvmlEventSetCreate
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(set)
    }
    pub unsafe fn nvmlDeviceRegisterEvents(
        &self,
        device: nvmlDevice_t,
        eventTypes: raw::c_ulonglong,
        set: nvmlEventSet_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceRegisterEvents
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, eventTypes, set)
    }
    pub unsafe fn nvmlDeviceGetSupportedEventTypes(
        &self,
        device: nvmlDevice_t,
        eventTypes: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetSupportedEventTypes
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, eventTypes)
    }
    pub unsafe fn nvmlEventSetWait_v2(
        &self,
        set: nvmlEventSet_t,
        data: *mut nvmlEventData_t,
        timeoutms: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlEventSetWait_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(set, data, timeoutms)
    }
    pub unsafe fn nvmlEventSetFree(&self, set: nvmlEventSet_t) -> nvmlReturn_t {
        let sym = self
            .nvmlEventSetFree
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(set)
    }
    pub unsafe fn nvmlDeviceModifyDrainState(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        newState: nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceModifyDrainState
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(pciInfo, newState)
    }
    pub unsafe fn nvmlDeviceQueryDrainState(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        currentState: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceQueryDrainState
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(pciInfo, currentState)
    }
    pub unsafe fn nvmlDeviceRemoveGpu_v2(
        &self,
        pciInfo: *mut nvmlPciInfo_t,
        gpuState: nvmlDetachGpuState_t,
        linkState: nvmlPcieLinkState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceRemoveGpu_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(pciInfo, gpuState, linkState)
    }
    pub unsafe fn nvmlDeviceDiscoverGpus(&self, pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceDiscoverGpus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(pciInfo)
    }
    pub unsafe fn nvmlDeviceGetFieldValues(
        &self,
        device: nvmlDevice_t,
        valuesCount: raw::c_int,
        values: *mut nvmlFieldValue_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetFieldValues
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, valuesCount, values)
    }
    pub unsafe fn nvmlDeviceGetVirtualizationMode(
        &self,
        device: nvmlDevice_t,
        pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetVirtualizationMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pVirtualMode)
    }
    pub unsafe fn nvmlDeviceGetHostVgpuMode(
        &self,
        device: nvmlDevice_t,
        pHostVgpuMode: *mut nvmlHostVgpuMode_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetHostVgpuMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pHostVgpuMode)
    }
    pub unsafe fn nvmlDeviceSetVirtualizationMode(
        &self,
        device: nvmlDevice_t,
        virtualMode: nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetVirtualizationMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, virtualMode)
    }
    pub unsafe fn nvmlDeviceGetGridLicensableFeatures_v3(
        &self,
        device: nvmlDevice_t,
        pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGridLicensableFeatures_v3
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pGridLicensableFeatures)
    }
    pub unsafe fn nvmlDeviceGetProcessUtilization(
        &self,
        device: nvmlDevice_t,
        utilization: *mut nvmlProcessUtilizationSample_t,
        processSamplesCount: *mut raw::c_uint,
        lastSeenTimeStamp: raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetProcessUtilization
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, utilization, processSamplesCount, lastSeenTimeStamp)
    }
    pub unsafe fn nvmlDeviceGetSupportedVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetSupportedVgpus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, vgpuCount, vgpuTypeIds)
    }
    pub unsafe fn nvmlDeviceGetCreatableVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetCreatableVgpus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, vgpuCount, vgpuTypeIds)
    }
    pub unsafe fn nvmlVgpuTypeGetClass(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeClass: *mut raw::c_char,
        size: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetClass
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, vgpuTypeClass, size)
    }
    pub unsafe fn nvmlVgpuTypeGetName(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeName: *mut raw::c_char,
        size: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetName
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, vgpuTypeName, size)
    }
    pub unsafe fn nvmlVgpuTypeGetGpuInstanceProfileId(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        gpuInstanceProfileId: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetGpuInstanceProfileId
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, gpuInstanceProfileId)
    }
    pub unsafe fn nvmlVgpuTypeGetDeviceID(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        deviceID: *mut raw::c_ulonglong,
        subsystemID: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetDeviceID
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, deviceID, subsystemID)
    }
    pub unsafe fn nvmlVgpuTypeGetFramebufferSize(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        fbSize: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetFramebufferSize
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, fbSize)
    }
    pub unsafe fn nvmlVgpuTypeGetNumDisplayHeads(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        numDisplayHeads: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetNumDisplayHeads
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, numDisplayHeads)
    }
    pub unsafe fn nvmlVgpuTypeGetResolution(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        displayIndex: raw::c_uint,
        xdim: *mut raw::c_uint,
        ydim: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetResolution
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, displayIndex, xdim, ydim)
    }
    pub unsafe fn nvmlVgpuTypeGetLicense(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeLicenseString: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetLicense
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, vgpuTypeLicenseString, size)
    }
    pub unsafe fn nvmlVgpuTypeGetFrameRateLimit(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        frameRateLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetFrameRateLimit
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, frameRateLimit)
    }
    pub unsafe fn nvmlVgpuTypeGetMaxInstances(
        &self,
        device: nvmlDevice_t,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCount: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetMaxInstances
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, vgpuTypeId, vgpuInstanceCount)
    }
    pub unsafe fn nvmlVgpuTypeGetMaxInstancesPerVm(
        &self,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCountPerVm: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuTypeGetMaxInstancesPerVm
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuTypeId, vgpuInstanceCountPerVm)
    }
    pub unsafe fn nvmlDeviceGetActiveVgpus(
        &self,
        device: nvmlDevice_t,
        vgpuCount: *mut raw::c_uint,
        vgpuInstances: *mut nvmlVgpuInstance_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetActiveVgpus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, vgpuCount, vgpuInstances)
    }
    pub unsafe fn nvmlVgpuInstanceGetVmID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vmId: *mut raw::c_char,
        size: raw::c_uint,
        vmIdType: *mut nvmlVgpuVmIdType_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetVmID
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, vmId, size, vmIdType)
    }
    pub unsafe fn nvmlVgpuInstanceGetUUID(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        uuid: *mut raw::c_char,
        size: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetUUID
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, uuid, size)
    }
    pub unsafe fn nvmlVgpuInstanceGetVmDriverVersion(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        version: *mut raw::c_char,
        length: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetVmDriverVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, version, length)
    }
    pub unsafe fn nvmlVgpuInstanceGetFbUsage(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        fbUsage: *mut raw::c_ulonglong,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetFbUsage
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, fbUsage)
    }
    pub unsafe fn nvmlVgpuInstanceGetLicenseStatus(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        licensed: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetLicenseStatus
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, licensed)
    }
    pub unsafe fn nvmlVgpuInstanceGetType(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuTypeId: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetType
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, vgpuTypeId)
    }
    pub unsafe fn nvmlVgpuInstanceGetFrameRateLimit(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        frameRateLimit: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetFrameRateLimit
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, frameRateLimit)
    }
    pub unsafe fn nvmlVgpuInstanceGetEccMode(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        eccMode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetEccMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, eccMode)
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderCapacity(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, encoderCapacity)
    }
    pub unsafe fn nvmlVgpuInstanceSetEncoderCapacity(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceSetEncoderCapacity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, encoderCapacity)
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        averageFps: *mut raw::c_uint,
        averageLatency: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetEncoderStats
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, sessionCount, averageFps, averageLatency)
    }
    pub unsafe fn nvmlVgpuInstanceGetEncoderSessions(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetEncoderSessions
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, sessionCount, sessionInfo)
    }
    pub unsafe fn nvmlVgpuInstanceGetFBCStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetFBCStats
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, fbcStats)
    }
    pub unsafe fn nvmlVgpuInstanceGetFBCSessions(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetFBCSessions
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, sessionCount, sessionInfo)
    }
    pub unsafe fn nvmlVgpuInstanceGetMetadata(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetMetadata
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, vgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlDeviceGetVgpuMetadata(
        &self,
        device: nvmlDevice_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetVgpuMetadata
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlGetVgpuCompatibility(
        &self,
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGetVgpuCompatibility
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuMetadata, pgpuMetadata, compatibilityInfo)
    }
    pub unsafe fn nvmlDeviceGetPgpuMetadataString(
        &self,
        device: nvmlDevice_t,
        pgpuMetadata: *mut raw::c_char,
        bufferSize: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetPgpuMetadataString
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, pgpuMetadata, bufferSize)
    }
    pub unsafe fn nvmlGetVgpuVersion(
        &self,
        supported: *mut nvmlVgpuVersion_t,
        current: *mut nvmlVgpuVersion_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGetVgpuVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(supported, current)
    }
    pub unsafe fn nvmlSetVgpuVersion(&self, vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t {
        let sym = self
            .nvmlSetVgpuVersion
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuVersion)
    }
    pub unsafe fn nvmlDeviceGetVgpuUtilization(
        &self,
        device: nvmlDevice_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        vgpuInstanceSamplesCount: *mut raw::c_uint,
        utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetVgpuUtilization
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            device,
            lastSeenTimeStamp,
            sampleValType,
            vgpuInstanceSamplesCount,
            utilizationSamples,
        )
    }
    pub unsafe fn nvmlDeviceGetVgpuProcessUtilization(
        &self,
        device: nvmlDevice_t,
        lastSeenTimeStamp: raw::c_ulonglong,
        vgpuProcessSamplesCount: *mut raw::c_uint,
        utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetVgpuProcessUtilization
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(
            device,
            lastSeenTimeStamp,
            vgpuProcessSamplesCount,
            utilizationSamples,
        )
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingMode(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetAccountingMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, mode)
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingPids(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        count: *mut raw::c_uint,
        pids: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetAccountingPids
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, count, pids)
    }
    pub unsafe fn nvmlVgpuInstanceGetAccountingStats(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
        pid: raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceGetAccountingStats
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance, pid, stats)
    }
    pub unsafe fn nvmlVgpuInstanceClearAccountingPids(
        &self,
        vgpuInstance: nvmlVgpuInstance_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlVgpuInstanceClearAccountingPids
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(vgpuInstance)
    }
    pub unsafe fn nvmlGetBlacklistDeviceCount(
        &self,
        deviceCount: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGetBlacklistDeviceCount
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(deviceCount)
    }
    pub unsafe fn nvmlGetBlacklistDeviceInfoByIndex(
        &self,
        index: raw::c_uint,
        info: *mut nvmlBlacklistDeviceInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGetBlacklistDeviceInfoByIndex
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(index, info)
    }
    pub unsafe fn nvmlDeviceSetMigMode(
        &self,
        device: nvmlDevice_t,
        mode: raw::c_uint,
        activationStatus: *mut nvmlReturn_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceSetMigMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, mode, activationStatus)
    }
    pub unsafe fn nvmlDeviceGetMigMode(
        &self,
        device: nvmlDevice_t,
        currentMode: *mut raw::c_uint,
        pendingMode: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMigMode
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, currentMode, pendingMode)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceProfileInfo(
        &self,
        device: nvmlDevice_t,
        profile: raw::c_uint,
        info: *mut nvmlGpuInstanceProfileInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGpuInstanceProfileInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, profile, info)
    }
    pub unsafe fn nvmlDeviceGetGpuInstancePossiblePlacements(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        placements: *mut nvmlGpuInstancePlacement_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGpuInstancePossiblePlacements
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, profileId, placements, count)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceRemainingCapacity(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGpuInstanceRemainingCapacity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, profileId, count)
    }
    pub unsafe fn nvmlDeviceCreateGpuInstance(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceCreateGpuInstance
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, profileId, gpuInstance)
    }
    pub unsafe fn nvmlGpuInstanceDestroy(&self, gpuInstance: nvmlGpuInstance_t) -> nvmlReturn_t {
        let sym = self
            .nvmlGpuInstanceDestroy
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(gpuInstance)
    }
    pub unsafe fn nvmlDeviceGetGpuInstances(
        &self,
        device: nvmlDevice_t,
        profileId: raw::c_uint,
        gpuInstances: *mut nvmlGpuInstance_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGpuInstances
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, profileId, gpuInstances, count)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceById(
        &self,
        device: nvmlDevice_t,
        id: raw::c_uint,
        gpuInstance: *mut nvmlGpuInstance_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGpuInstanceById
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, id, gpuInstance)
    }
    pub unsafe fn nvmlGpuInstanceGetInfo(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        info: *mut nvmlGpuInstanceInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGpuInstanceGetInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(gpuInstance, info)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceProfileInfo(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profile: raw::c_uint,
        engProfile: raw::c_uint,
        info: *mut nvmlComputeInstanceProfileInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGpuInstanceGetComputeInstanceProfileInfo
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(gpuInstance, profile, engProfile, info)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceRemainingCapacity(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGpuInstanceGetComputeInstanceRemainingCapacity
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(gpuInstance, profileId, count)
    }
    pub unsafe fn nvmlGpuInstanceCreateComputeInstance(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGpuInstanceCreateComputeInstance
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(gpuInstance, profileId, computeInstance)
    }
    pub unsafe fn nvmlComputeInstanceDestroy(
        &self,
        computeInstance: nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlComputeInstanceDestroy
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(computeInstance)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstances(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        profileId: raw::c_uint,
        computeInstances: *mut nvmlComputeInstance_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGpuInstanceGetComputeInstances
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(gpuInstance, profileId, computeInstances, count)
    }
    pub unsafe fn nvmlGpuInstanceGetComputeInstanceById(
        &self,
        gpuInstance: nvmlGpuInstance_t,
        id: raw::c_uint,
        computeInstance: *mut nvmlComputeInstance_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlGpuInstanceGetComputeInstanceById
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(gpuInstance, id, computeInstance)
    }
    pub unsafe fn nvmlComputeInstanceGetInfo_v2(
        &self,
        computeInstance: nvmlComputeInstance_t,
        info: *mut nvmlComputeInstanceInfo_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlComputeInstanceGetInfo_v2
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(computeInstance, info)
    }
    pub unsafe fn nvmlDeviceIsMigDeviceHandle(
        &self,
        device: nvmlDevice_t,
        isMigDevice: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceIsMigDeviceHandle
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, isMigDevice)
    }
    pub unsafe fn nvmlDeviceGetGpuInstanceId(
        &self,
        device: nvmlDevice_t,
        id: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetGpuInstanceId
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, id)
    }
    pub unsafe fn nvmlDeviceGetComputeInstanceId(
        &self,
        device: nvmlDevice_t,
        id: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetComputeInstanceId
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, id)
    }
    pub unsafe fn nvmlDeviceGetMaxMigDeviceCount(
        &self,
        device: nvmlDevice_t,
        count: *mut raw::c_uint,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMaxMigDeviceCount
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, count)
    }
    pub unsafe fn nvmlDeviceGetMigDeviceHandleByIndex(
        &self,
        device: nvmlDevice_t,
        index: raw::c_uint,
        migDevice: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetMigDeviceHandleByIndex
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(device, index, migDevice)
    }
    pub unsafe fn nvmlDeviceGetDeviceHandleFromMigDeviceHandle(
        &self,
        migDevice: nvmlDevice_t,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t {
        let sym = self
            .nvmlDeviceGetDeviceHandleFromMigDeviceHandle
            .as_ref()
            .expect("Expected function, got error.");
        (sym)(migDevice, device)
    }
}
