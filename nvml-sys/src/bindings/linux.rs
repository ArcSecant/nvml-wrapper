#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

/* automatically generated by rust-bindgen */

pub const NVML_API_VERSION: ::std::os::raw::c_uint = 8;
pub const NVML_API_VERSION_STR: &'static [u8; 2usize] = b"8\x00";
pub const NVML_VALUE_NOT_AVAILABLE: ::std::os::raw::c_int = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: ::std::os::raw::c_uint = 16;
pub const NVML_NVLINK_MAX_LINKS: ::std::os::raw::c_uint = 4;
pub const NVML_MAX_PHYSICAL_BRIDGE: ::std::os::raw::c_uint = 128;
pub const nvmlFlagDefault: ::std::os::raw::c_uint = 0;
pub const nvmlFlagForce: ::std::os::raw::c_uint = 1;
pub const nvmlEventTypeSingleBitEccError: ::std::os::raw::c_uint = 1;
pub const nvmlEventTypeDoubleBitEccError: ::std::os::raw::c_uint = 2;
pub const nvmlEventTypePState: ::std::os::raw::c_uint = 4;
pub const nvmlEventTypeXidCriticalError: ::std::os::raw::c_uint = 8;
pub const nvmlEventTypeClock: ::std::os::raw::c_uint = 16;
pub const nvmlEventTypeNone: ::std::os::raw::c_uint = 0;
pub const nvmlEventTypeAll: ::std::os::raw::c_uint = 31;
pub const nvmlClocksThrottleReasonGpuIdle: ::std::os::raw::c_uint = 1;
pub const nvmlClocksThrottleReasonApplicationsClocksSetting:
          ::std::os::raw::c_uint =
    2;
pub const nvmlClocksThrottleReasonUserDefinedClocks: ::std::os::raw::c_uint =
    2;
pub const nvmlClocksThrottleReasonSwPowerCap: ::std::os::raw::c_uint = 4;
pub const nvmlClocksThrottleReasonHwSlowdown: ::std::os::raw::c_uint = 8;
pub const nvmlClocksThrottleReasonSyncBoost: ::std::os::raw::c_uint = 16;
pub const nvmlClocksThrottleReasonUnknown: ::std::os::raw::c_longlong =
    -9223372036854775808;
pub const nvmlClocksThrottleReasonNone: ::std::os::raw::c_uint = 0;
pub const nvmlClocksThrottleReasonAll: ::std::os::raw::c_longlong =
    -9223372036854775777;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: ::std::os::raw::c_uint =
    16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: ::std::os::raw::c_uint = 80;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: ::std::os::raw::c_uint = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: ::std::os::raw::c_uint = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: ::std::os::raw::c_uint = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: ::std::os::raw::c_uint = 64;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: ::std::os::raw::c_uint = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: ::std::os::raw::c_uint = 32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDevice_st([u8; 0]);
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlPciInfo_st {
    pub busId: [::std::os::raw::c_char; 16usize],
    pub domain: ::std::os::raw::c_uint,
    pub bus: ::std::os::raw::c_uint,
    pub device: ::std::os::raw::c_uint,
    pub pciDeviceId: ::std::os::raw::c_uint,
    pub pciSubSystemId: ::std::os::raw::c_uint,
    pub reserved0: ::std::os::raw::c_uint,
    pub reserved1: ::std::os::raw::c_uint,
    pub reserved2: ::std::os::raw::c_uint,
    pub reserved3: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlPciInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlPciInfo_st>() , 52usize , concat ! (
               "Size of: " , stringify ! ( nvmlPciInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlPciInfo_st>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nvmlPciInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . busId as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( busId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . domain as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . bus as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . device as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . pciDeviceId as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( pciDeviceId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . pciSubSystemId as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( pciSubSystemId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . reserved0 as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( reserved0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . reserved1 as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . reserved2 as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPciInfo_st ) ) . reserved3 as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPciInfo_st ) , "::"
                , stringify ! ( reserved3 ) ));
}
impl Clone for nvmlPciInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlEccErrorCounts_st {
    pub l1Cache: ::std::os::raw::c_ulonglong,
    pub l2Cache: ::std::os::raw::c_ulonglong,
    pub deviceMemory: ::std::os::raw::c_ulonglong,
    pub registerFile: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEccErrorCounts_st() {
    assert_eq!(::std::mem::size_of::<nvmlEccErrorCounts_st>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlEccErrorCounts_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlEccErrorCounts_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlEccErrorCounts_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . l1Cache as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( l1Cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . l2Cache as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( l2Cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . deviceMemory
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( deviceMemory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEccErrorCounts_st ) ) . registerFile
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEccErrorCounts_st )
                , "::" , stringify ! ( registerFile ) ));
}
impl Clone for nvmlEccErrorCounts_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlUtilization_st {
    pub gpu: ::std::os::raw::c_uint,
    pub memory: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUtilization_st() {
    assert_eq!(::std::mem::size_of::<nvmlUtilization_st>() , 8usize , concat !
               ( "Size of: " , stringify ! ( nvmlUtilization_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUtilization_st>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlUtilization_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUtilization_st ) ) . gpu as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUtilization_st ) ,
                "::" , stringify ! ( gpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUtilization_st ) ) . memory as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUtilization_st ) ,
                "::" , stringify ! ( memory ) ));
}
impl Clone for nvmlUtilization_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlMemory_st {
    pub total: ::std::os::raw::c_ulonglong,
    pub free: ::std::os::raw::c_ulonglong,
    pub used: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlMemory_st() {
    assert_eq!(::std::mem::size_of::<nvmlMemory_st>() , 24usize , concat ! (
               "Size of: " , stringify ! ( nvmlMemory_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlMemory_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlMemory_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . total as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . free as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlMemory_st ) ) . used as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlMemory_st ) , "::"
                , stringify ! ( used ) ));
}
impl Clone for nvmlMemory_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlMemory_t = nvmlMemory_st;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlBAR1Memory_st {
    pub bar1Total: ::std::os::raw::c_ulonglong,
    pub bar1Free: ::std::os::raw::c_ulonglong,
    pub bar1Used: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlBAR1Memory_st() {
    assert_eq!(::std::mem::size_of::<nvmlBAR1Memory_st>() , 24usize , concat !
               ( "Size of: " , stringify ! ( nvmlBAR1Memory_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlBAR1Memory_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlBAR1Memory_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Total as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Free as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBAR1Memory_st ) ) . bar1Used as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBAR1Memory_st ) ,
                "::" , stringify ! ( bar1Used ) ));
}
impl Clone for nvmlBAR1Memory_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlProcessInfo_st {
    pub pid: ::std::os::raw::c_uint,
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlProcessInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlProcessInfo_st>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( nvmlProcessInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlProcessInfo_st>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlProcessInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessInfo_st ) ) . pid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlProcessInfo_st ) ,
                "::" , stringify ! ( pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlProcessInfo_st ) ) . usedGpuMemory as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlProcessInfo_st ) ,
                "::" , stringify ! ( usedGpuMemory ) ));
}
impl Clone for nvmlProcessInfo_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlBridgeChipType_enum {
    NVML_BRIDGE_CHIP_PLX = 0,
    NVML_BRIDGE_CHIP_BRO4 = 1,
}
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlNvLinkUtilizationCountUnits_enum {
    NVML_NVLINK_COUNTER_UNIT_CYCLES = 0,
    NVML_NVLINK_COUNTER_UNIT_PACKETS = 1,
    NVML_NVLINK_COUNTER_UNIT_BYTES = 2,
    NVML_NVLINK_COUNTER_UNIT_COUNT = 3,
}
pub use self::nvmlNvLinkUtilizationCountUnits_enum as
        nvmlNvLinkUtilizationCountUnits_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlNvLinkUtilizationCountPktTypes_enum {
    NVML_NVLINK_COUNTER_PKTFILTER_NOP = 1,
    NVML_NVLINK_COUNTER_PKTFILTER_READ = 2,
    NVML_NVLINK_COUNTER_PKTFILTER_WRITE = 4,
    NVML_NVLINK_COUNTER_PKTFILTER_RATOM = 8,
    NVML_NVLINK_COUNTER_PKTFILTER_NRATOM = 16,
    NVML_NVLINK_COUNTER_PKTFILTER_FLUSH = 32,
    NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA = 64,
    NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA = 128,
    NVML_NVLINK_COUNTER_PKTFILTER_ALL = 255,
}
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as
        nvmlNvLinkUtilizationCountPktTypes_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
#[test]
fn bindgen_test_layout_nvmlNvLinkUtilizationControl_st() {
    assert_eq!(::std::mem::size_of::<nvmlNvLinkUtilizationControl_st>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( nvmlNvLinkUtilizationControl_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlNvLinkUtilizationControl_st>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlNvLinkUtilizationControl_st ) ) .
                units as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) , "::" , stringify ! ( units
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlNvLinkUtilizationControl_st ) ) .
                pktfilter as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlNvLinkUtilizationControl_st ) , "::" , stringify ! (
                pktfilter ) ));
}
impl Clone for nvmlNvLinkUtilizationControl_st {
    fn clone(&self) -> Self { *self }
}
impl Default for nvmlNvLinkUtilizationControl_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlNvLinkCapability_enum {
    NVML_NVLINK_CAP_P2P_SUPPORTED = 0,
    NVML_NVLINK_CAP_SYSMEM_ACCESS = 1,
    NVML_NVLINK_CAP_P2P_ATOMICS = 2,
    NVML_NVLINK_CAP_SYSMEM_ATOMICS = 3,
    NVML_NVLINK_CAP_SLI_BRIDGE = 4,
    NVML_NVLINK_CAP_VALID = 5,
    NVML_NVLINK_CAP_COUNT = 6,
}
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlNvLinkErrorCounter_enum {
    NVML_NVLINK_ERROR_DL_REPLAY = 0,
    NVML_NVLINK_ERROR_DL_RECOVERY = 1,
    NVML_NVLINK_ERROR_DL_CRC_FLIT = 2,
    NVML_NVLINK_ERROR_DL_CRC_DATA = 3,
    NVML_NVLINK_ERROR_COUNT = 4,
}
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlGpuLevel_enum {
    NVML_TOPOLOGY_INTERNAL = 0,
    NVML_TOPOLOGY_SINGLE = 10,
    NVML_TOPOLOGY_MULTIPLE = 20,
    NVML_TOPOLOGY_HOSTBRIDGE = 30,
    NVML_TOPOLOGY_CPU = 40,
    NVML_TOPOLOGY_SYSTEM = 50,
}
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlGpuP2PStatus_enum {
    NVML_P2P_STATUS_OK = 0,
    NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED = 1,
    NVML_P2P_STATUS_GPU_NOT_SUPPORTED = 2,
    NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED = 3,
    NVML_P2P_STATUS_DISABLED_BY_REGKEY = 4,
    NVML_P2P_STATUS_NOT_SUPPORTED = 5,
    NVML_P2P_STATUS_UNKNOWN = 6,
}
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlGpuP2PCapsIndex_enum {
    NVML_P2P_CAPS_INDEX_READ = 0,
    NVML_P2P_CAPS_INDEX_WRITE = 1,
    NVML_P2P_CAPS_INDEX_NVLINK = 2,
    NVML_P2P_CAPS_INDEX_ATOMICS = 3,
    NVML_P2P_CAPS_INDEX_PROP = 4,
    NVML_P2P_CAPS_INDEX_UNKNOWN = 5,
}
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlBridgeChipInfo_st {
    pub type_: nvmlBridgeChipType_t,
    pub fwVersion: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlBridgeChipInfo_st>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlBridgeChipInfo_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlBridgeChipInfo_st>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlBridgeChipInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipInfo_st ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBridgeChipInfo_st )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipInfo_st ) ) . fwVersion as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlBridgeChipInfo_st )
                , "::" , stringify ! ( fwVersion ) ));
}
impl Clone for nvmlBridgeChipInfo_st {
    fn clone(&self) -> Self { *self }
}
impl Default for nvmlBridgeChipInfo_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[repr(C)]
pub struct nvmlBridgeChipHierarchy_st {
    pub bridgeCount: ::std::os::raw::c_uchar,
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipHierarchy_st() {
    assert_eq!(::std::mem::size_of::<nvmlBridgeChipHierarchy_st>() , 1028usize
               , concat ! (
               "Size of: " , stringify ! ( nvmlBridgeChipHierarchy_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlBridgeChipHierarchy_st>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( nvmlBridgeChipHierarchy_st )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipHierarchy_st ) ) .
                bridgeCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlBridgeChipHierarchy_st ) , "::" , stringify ! (
                bridgeCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlBridgeChipHierarchy_st ) ) .
                bridgeChipInfo as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                nvmlBridgeChipHierarchy_st ) , "::" , stringify ! (
                bridgeChipInfo ) ));
}
impl Default for nvmlBridgeChipHierarchy_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlSamplingType_enum {
    NVML_TOTAL_POWER_SAMPLES = 0,
    NVML_GPU_UTILIZATION_SAMPLES = 1,
    NVML_MEMORY_UTILIZATION_SAMPLES = 2,
    NVML_ENC_UTILIZATION_SAMPLES = 3,
    NVML_DEC_UTILIZATION_SAMPLES = 4,
    NVML_PROCESSOR_CLK_SAMPLES = 5,
    NVML_MEMORY_CLK_SAMPLES = 6,
    NVML_SAMPLINGTYPE_COUNT = 7,
}
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlPcieUtilCounter_enum {
    NVML_PCIE_UTIL_TX_BYTES = 0,
    NVML_PCIE_UTIL_RX_BYTES = 1,
    NVML_PCIE_UTIL_COUNT = 2,
}
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlValueType_enum {
    NVML_VALUE_TYPE_DOUBLE = 0,
    NVML_VALUE_TYPE_UNSIGNED_INT = 1,
    NVML_VALUE_TYPE_UNSIGNED_LONG = 2,
    NVML_VALUE_TYPE_UNSIGNED_LONG_LONG = 3,
    NVML_VALUE_TYPE_COUNT = 4,
}
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[repr(C)]
#[derive(Copy)]
#[cfg(feature = "nightly")]
pub union nvmlValue_st {
    pub dVal: f64,
    pub uiVal: ::std::os::raw::c_uint,
    pub ulVal: ::std::os::raw::c_ulong,
    pub ullVal: ::std::os::raw::c_ulonglong,
}
#[test]
#[cfg(feature = "nightly")]
fn bindgen_test_layout_nvmlValue_st() {
    assert_eq!(::std::mem::size_of::<nvmlValue_st>() , 8usize , concat ! (
               "Size of: " , stringify ! ( nvmlValue_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlValue_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlValue_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . dVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( dVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . uiVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( uiVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . ulVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( ulVal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlValue_st ) ) . ullVal as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlValue_st ) , "::" ,
                stringify ! ( ullVal ) ));
}
#[cfg(feature = "nightly")]
impl Clone for nvmlValue_st {
    fn clone(&self) -> Self { *self }
}
#[cfg(feature = "nightly")]
impl Default for nvmlValue_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[cfg(feature = "nightly")]
pub type nvmlValue_t = nvmlValue_st;
#[repr(C)]
#[derive(Copy)]
#[cfg(feature = "nightly")]
pub struct nvmlSample_st {
    pub timeStamp: ::std::os::raw::c_ulonglong,
    pub sampleValue: nvmlValue_t,
}
#[test]
#[cfg(feature = "nightly")]
fn bindgen_test_layout_nvmlSample_st() {
    assert_eq!(::std::mem::size_of::<nvmlSample_st>() , 16usize , concat ! (
               "Size of: " , stringify ! ( nvmlSample_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlSample_st>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( nvmlSample_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlSample_st ) ) . timeStamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlSample_st ) , "::"
                , stringify ! ( timeStamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlSample_st ) ) . sampleValue as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlSample_st ) , "::"
                , stringify ! ( sampleValue ) ));
}
#[cfg(feature = "nightly")]
impl Clone for nvmlSample_st {
    fn clone(&self) -> Self { *self }
}
#[cfg(feature = "nightly")]
impl Default for nvmlSample_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[cfg(feature = "nightly")]
pub type nvmlSample_t = nvmlSample_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlPerfPolicyType_enum {
    NVML_PERF_POLICY_POWER = 0,
    NVML_PERF_POLICY_THERMAL = 1,
    NVML_PERF_POLICY_SYNC_BOOST = 2,
    NVML_PERF_POLICY_COUNT = 3,
}
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlViolationTime_st {
    pub referenceTime: ::std::os::raw::c_ulonglong,
    pub violationTime: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlViolationTime_st() {
    assert_eq!(::std::mem::size_of::<nvmlViolationTime_st>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlViolationTime_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlViolationTime_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlViolationTime_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlViolationTime_st ) ) . referenceTime
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlViolationTime_st )
                , "::" , stringify ! ( referenceTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlViolationTime_st ) ) . violationTime
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlViolationTime_st )
                , "::" , stringify ! ( violationTime ) ));
}
impl Clone for nvmlViolationTime_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlEnableState_enum {
    NVML_FEATURE_DISABLED = 0,
    NVML_FEATURE_ENABLED = 1,
}
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlBrandType_enum {
    NVML_BRAND_UNKNOWN = 0,
    NVML_BRAND_QUADRO = 1,
    NVML_BRAND_TESLA = 2,
    NVML_BRAND_NVS = 3,
    NVML_BRAND_GRID = 4,
    NVML_BRAND_GEFORCE = 5,
    NVML_BRAND_COUNT = 6,
}
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlTemperatureThresholds_enum {
    NVML_TEMPERATURE_THRESHOLD_SHUTDOWN = 0,
    NVML_TEMPERATURE_THRESHOLD_SLOWDOWN = 1,
    NVML_TEMPERATURE_THRESHOLD_COUNT = 2,
}
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlTemperatureSensors_enum {
    NVML_TEMPERATURE_GPU = 0,
    NVML_TEMPERATURE_COUNT = 1,
}
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlComputeMode_enum {
    NVML_COMPUTEMODE_DEFAULT = 0,
    NVML_COMPUTEMODE_EXCLUSIVE_THREAD = 1,
    NVML_COMPUTEMODE_PROHIBITED = 2,
    NVML_COMPUTEMODE_EXCLUSIVE_PROCESS = 3,
    NVML_COMPUTEMODE_COUNT = 4,
}
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlMemoryErrorType_enum {
    NVML_MEMORY_ERROR_TYPE_CORRECTED = 0,
    NVML_MEMORY_ERROR_TYPE_UNCORRECTED = 1,
    NVML_MEMORY_ERROR_TYPE_COUNT = 2,
}
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlEccCounterType_enum {
    NVML_VOLATILE_ECC = 0,
    NVML_AGGREGATE_ECC = 1,
    NVML_ECC_COUNTER_TYPE_COUNT = 2,
}
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlClockType_enum {
    NVML_CLOCK_GRAPHICS = 0,
    NVML_CLOCK_SM = 1,
    NVML_CLOCK_MEM = 2,
    NVML_CLOCK_VIDEO = 3,
    NVML_CLOCK_COUNT = 4,
}
pub use self::nvmlClockType_enum as nvmlClockType_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlClockId_enum {
    NVML_CLOCK_ID_CURRENT = 0,
    NVML_CLOCK_ID_APP_CLOCK_TARGET = 1,
    NVML_CLOCK_ID_APP_CLOCK_DEFAULT = 2,
    NVML_CLOCK_ID_CUSTOMER_BOOST_MAX = 3,
    NVML_CLOCK_ID_COUNT = 4,
}
pub use self::nvmlClockId_enum as nvmlClockId_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlDriverModel_enum { NVML_DRIVER_WDDM = 0, NVML_DRIVER_WDM = 1, }
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlPStates_enum {
    NVML_PSTATE_0 = 0,
    NVML_PSTATE_1 = 1,
    NVML_PSTATE_2 = 2,
    NVML_PSTATE_3 = 3,
    NVML_PSTATE_4 = 4,
    NVML_PSTATE_5 = 5,
    NVML_PSTATE_6 = 6,
    NVML_PSTATE_7 = 7,
    NVML_PSTATE_8 = 8,
    NVML_PSTATE_9 = 9,
    NVML_PSTATE_10 = 10,
    NVML_PSTATE_11 = 11,
    NVML_PSTATE_12 = 12,
    NVML_PSTATE_13 = 13,
    NVML_PSTATE_14 = 14,
    NVML_PSTATE_15 = 15,
    NVML_PSTATE_UNKNOWN = 32,
}
pub use self::nvmlPStates_enum as nvmlPstates_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlGom_enum {
    NVML_GOM_ALL_ON = 0,
    NVML_GOM_COMPUTE = 1,
    NVML_GOM_LOW_DP = 2,
}
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlInforomObject_enum {
    NVML_INFOROM_OEM = 0,
    NVML_INFOROM_ECC = 1,
    NVML_INFOROM_POWER = 2,
    NVML_INFOROM_COUNT = 3,
}
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlReturn_enum {
    NVML_SUCCESS = 0,
    NVML_ERROR_UNINITIALIZED = 1,
    NVML_ERROR_INVALID_ARGUMENT = 2,
    NVML_ERROR_NOT_SUPPORTED = 3,
    NVML_ERROR_NO_PERMISSION = 4,
    NVML_ERROR_ALREADY_INITIALIZED = 5,
    NVML_ERROR_NOT_FOUND = 6,
    NVML_ERROR_INSUFFICIENT_SIZE = 7,
    NVML_ERROR_INSUFFICIENT_POWER = 8,
    NVML_ERROR_DRIVER_NOT_LOADED = 9,
    NVML_ERROR_TIMEOUT = 10,
    NVML_ERROR_IRQ_ISSUE = 11,
    NVML_ERROR_LIBRARY_NOT_FOUND = 12,
    NVML_ERROR_FUNCTION_NOT_FOUND = 13,
    NVML_ERROR_CORRUPTED_INFOROM = 14,
    NVML_ERROR_GPU_IS_LOST = 15,
    NVML_ERROR_RESET_REQUIRED = 16,
    NVML_ERROR_OPERATING_SYSTEM = 17,
    NVML_ERROR_LIB_RM_VERSION_MISMATCH = 18,
    NVML_ERROR_IN_USE = 19,
    NVML_ERROR_NO_DATA = 20,
    NVML_ERROR_UNKNOWN = 999,
}
pub use self::nvmlReturn_enum as nvmlReturn_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlMemoryLocation_enum {
    NVML_MEMORY_LOCATION_L1_CACHE = 0,
    NVML_MEMORY_LOCATION_L2_CACHE = 1,
    NVML_MEMORY_LOCATION_DEVICE_MEMORY = 2,
    NVML_MEMORY_LOCATION_REGISTER_FILE = 3,
    NVML_MEMORY_LOCATION_TEXTURE_MEMORY = 4,
    NVML_MEMORY_LOCATION_TEXTURE_SHM = 5,
    NVML_MEMORY_LOCATION_COUNT = 6,
}
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlPageRetirementCause_enum {
    NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS = 0,
    NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR = 1,
    NVML_PAGE_RETIREMENT_CAUSE_COUNT = 2,
}
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlRestrictedAPI_enum {
    NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS = 0,
    NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS = 1,
    NVML_RESTRICTED_API_COUNT = 2,
}
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnit_st([u8; 0]);
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: ::std::os::raw::c_uint,
    pub firmwareVersion: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_nvmlHwbcEntry_st() {
    assert_eq!(::std::mem::size_of::<nvmlHwbcEntry_st>() , 36usize , concat !
               ( "Size of: " , stringify ! ( nvmlHwbcEntry_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlHwbcEntry_st>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( nvmlHwbcEntry_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlHwbcEntry_st ) ) . hwbcId as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlHwbcEntry_st ) ,
                "::" , stringify ! ( hwbcId ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlHwbcEntry_st ) ) . firmwareVersion as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlHwbcEntry_st ) ,
                "::" , stringify ! ( firmwareVersion ) ));
}
impl Clone for nvmlHwbcEntry_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlFanState_enum { NVML_FAN_NORMAL = 0, NVML_FAN_FAILED = 1, }
pub use self::nvmlFanState_enum as nvmlFanState_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum nvmlLedColor_enum {
    NVML_LED_COLOR_GREEN = 0,
    NVML_LED_COLOR_AMBER = 1,
}
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[repr(C)]
pub struct nvmlLedState_st {
    pub cause: [::std::os::raw::c_char; 256usize],
    pub color: nvmlLedColor_t,
}
#[test]
fn bindgen_test_layout_nvmlLedState_st() {
    assert_eq!(::std::mem::size_of::<nvmlLedState_st>() , 260usize , concat !
               ( "Size of: " , stringify ! ( nvmlLedState_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlLedState_st>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( nvmlLedState_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlLedState_st ) ) . cause as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlLedState_st ) ,
                "::" , stringify ! ( cause ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlLedState_st ) ) . color as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlLedState_st ) ,
                "::" , stringify ! ( color ) ));
}
impl Default for nvmlLedState_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlLedState_t = nvmlLedState_st;
#[repr(C)]
pub struct nvmlUnitInfo_st {
    pub name: [::std::os::raw::c_char; 96usize],
    pub id: [::std::os::raw::c_char; 96usize],
    pub serial: [::std::os::raw::c_char; 96usize],
    pub firmwareVersion: [::std::os::raw::c_char; 96usize],
}
#[test]
fn bindgen_test_layout_nvmlUnitInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitInfo_st>() , 384usize , concat !
               ( "Size of: " , stringify ! ( nvmlUnitInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUnitInfo_st>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( nvmlUnitInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . id as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . serial as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( serial ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitInfo_st ) ) . firmwareVersion as
                * const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitInfo_st ) ,
                "::" , stringify ! ( firmwareVersion ) ));
}
impl Default for nvmlUnitInfo_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[repr(C)]
pub struct nvmlPSUInfo_st {
    pub state: [::std::os::raw::c_char; 256usize],
    pub current: ::std::os::raw::c_uint,
    pub voltage: ::std::os::raw::c_uint,
    pub power: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlPSUInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlPSUInfo_st>() , 268usize , concat ! (
               "Size of: " , stringify ! ( nvmlPSUInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlPSUInfo_st>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( nvmlPSUInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . state as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . current as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . voltage as * const _
                as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( voltage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlPSUInfo_st ) ) . power as * const _
                as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlPSUInfo_st ) , "::"
                , stringify ! ( power ) ));
}
impl Default for nvmlPSUInfo_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlUnitFanInfo_st {
    pub speed: ::std::os::raw::c_uint,
    pub state: nvmlFanState_t,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanInfo_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitFanInfo_st>() , 8usize , concat !
               ( "Size of: " , stringify ! ( nvmlUnitFanInfo_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlUnitFanInfo_st>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( nvmlUnitFanInfo_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanInfo_st ) ) . speed as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanInfo_st ) ,
                "::" , stringify ! ( speed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanInfo_st ) ) . state as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanInfo_st ) ,
                "::" , stringify ! ( state ) ));
}
impl Clone for nvmlUnitFanInfo_st {
    fn clone(&self) -> Self { *self }
}
impl Default for nvmlUnitFanInfo_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlUnitFanSpeeds_st {
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanSpeeds_st() {
    assert_eq!(::std::mem::size_of::<nvmlUnitFanSpeeds_st>() , 196usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlUnitFanSpeeds_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlUnitFanSpeeds_st>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlUnitFanSpeeds_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanSpeeds_st ) ) . fans as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanSpeeds_st )
                , "::" , stringify ! ( fans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlUnitFanSpeeds_st ) ) . count as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlUnitFanSpeeds_st )
                , "::" , stringify ! ( count ) ));
}
impl Clone for nvmlUnitFanSpeeds_st {
    fn clone(&self) -> Self { *self }
}
impl Default for nvmlUnitFanSpeeds_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventSet_st([u8; 0]);
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct nvmlEventData_st {
    pub device: nvmlDevice_t,
    pub eventType: ::std::os::raw::c_ulonglong,
    pub eventData: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEventData_st() {
    assert_eq!(::std::mem::size_of::<nvmlEventData_st>() , 24usize , concat !
               ( "Size of: " , stringify ! ( nvmlEventData_st ) ));
    assert_eq! (::std::mem::align_of::<nvmlEventData_st>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( nvmlEventData_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . device as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . eventType as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( eventType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlEventData_st ) ) . eventData as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlEventData_st ) ,
                "::" , stringify ! ( eventData ) ));
}
impl Clone for nvmlEventData_st {
    fn clone(&self) -> Self { *self }
}
impl Default for nvmlEventData_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nvmlEventData_t = nvmlEventData_st;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct nvmlAccountingStats_st {
    pub gpuUtilization: ::std::os::raw::c_uint,
    pub memoryUtilization: ::std::os::raw::c_uint,
    pub maxMemoryUsage: ::std::os::raw::c_ulonglong,
    pub time: ::std::os::raw::c_ulonglong,
    pub startTime: ::std::os::raw::c_ulonglong,
    pub isRunning: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 5usize],
}
#[test]
fn bindgen_test_layout_nvmlAccountingStats_st() {
    assert_eq!(::std::mem::size_of::<nvmlAccountingStats_st>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( nvmlAccountingStats_st )
               ));
    assert_eq! (::std::mem::align_of::<nvmlAccountingStats_st>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( nvmlAccountingStats_st ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                gpuUtilization as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( gpuUtilization ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                memoryUtilization as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( memoryUtilization ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) .
                maxMemoryUsage as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( maxMemoryUsage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . time as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . startTime as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( startTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . isRunning as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( isRunning ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const nvmlAccountingStats_st ) ) . reserved as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( nvmlAccountingStats_st
                ) , "::" , stringify ! ( reserved ) ));
}
impl Clone for nvmlAccountingStats_st {
    fn clone(&self) -> Self { *self }
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
extern "C" {
    pub fn nvmlInit_v2() -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlShutdown() -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlErrorString(result: nvmlReturn_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nvmlSystemGetDriverVersion(version: *mut ::std::os::raw::c_char,
                                      length: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetNVMLVersion(version: *mut ::std::os::raw::c_char,
                                    length: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetProcessName(pid: ::std::os::raw::c_uint,
                                    name: *mut ::std::os::raw::c_char,
                                    length: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetCount(unitCount: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetHandleByIndex(index: ::std::os::raw::c_uint,
                                    unit: *mut nvmlUnit_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetUnitInfo(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetLedState(unit: nvmlUnit_t, state: *mut nvmlLedState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetPsuInfo(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetTemperature(unit: nvmlUnit_t,
                                  type_: ::std::os::raw::c_uint,
                                  temp: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetFanSpeedInfo(unit: nvmlUnit_t,
                                   fanSpeeds: *mut nvmlUnitFanSpeeds_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitGetDevices(unit: nvmlUnit_t,
                              deviceCount: *mut ::std::os::raw::c_uint,
                              devices: *mut nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetHicVersion(hwbcCount: *mut ::std::os::raw::c_uint,
                                   hwbcEntries: *mut nvmlHwbcEntry_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCount_v2(deviceCount: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByIndex_v2(index: ::std::os::raw::c_uint,
                                         device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleBySerial(serial: *const ::std::os::raw::c_char,
                                       device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByUUID(uuid: *const ::std::os::raw::c_char,
                                     device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByPciBusId_v2(pciBusId:
                                                *const ::std::os::raw::c_char,
                                            device: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetName(device: nvmlDevice_t,
                             name: *mut ::std::os::raw::c_char,
                             length: ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBrand(device: nvmlDevice_t,
                              type_: *mut nvmlBrandType_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetIndex(device: nvmlDevice_t,
                              index: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSerial(device: nvmlDevice_t,
                               serial: *mut ::std::os::raw::c_char,
                               length: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCpuAffinity(device: nvmlDevice_t,
                                    cpuSetSize: ::std::os::raw::c_uint,
                                    cpuSet: *mut ::std::os::raw::c_ulong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTopologyCommonAncestor(device1: nvmlDevice_t,
                                               device2: nvmlDevice_t,
                                               pathInfo:
                                                   *mut nvmlGpuTopologyLevel_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTopologyNearestGpus(device: nvmlDevice_t,
                                            level: nvmlGpuTopologyLevel_t,
                                            count:
                                                *mut ::std::os::raw::c_uint,
                                            deviceArray: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlSystemGetTopologyGpuSet(cpuNumber: ::std::os::raw::c_uint,
                                       count: *mut ::std::os::raw::c_uint,
                                       deviceArray: *mut nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetP2PStatus(device1: nvmlDevice_t,
                                  device2: nvmlDevice_t,
                                  p2pIndex: nvmlGpuP2PCapsIndex_t,
                                  p2pStatus: *mut nvmlGpuP2PStatus_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetUUID(device: nvmlDevice_t,
                             uuid: *mut ::std::os::raw::c_char,
                             length: ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMinorNumber(device: nvmlDevice_t,
                                    minorNumber: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBoardPartNumber(device: nvmlDevice_t,
                                        partNumber:
                                            *mut ::std::os::raw::c_char,
                                        length: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomVersion(device: nvmlDevice_t,
                                       object: nvmlInforomObject_t,
                                       version: *mut ::std::os::raw::c_char,
                                       length: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomImageVersion(device: nvmlDevice_t,
                                            version:
                                                *mut ::std::os::raw::c_char,
                                            length: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetInforomConfigurationChecksum(device: nvmlDevice_t,
                                                     checksum:
                                                         *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceValidateInforom(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDisplayMode(device: nvmlDevice_t,
                                    display: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDisplayActive(device: nvmlDevice_t,
                                      isActive: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPersistenceMode(device: nvmlDevice_t,
                                        mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPciInfo_v2(device: nvmlDevice_t,
                                   pci: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxPcieLinkGeneration(device: nvmlDevice_t,
                                              maxLinkGen:
                                                  *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxPcieLinkWidth(device: nvmlDevice_t,
                                         maxLinkWidth:
                                             *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrPcieLinkGeneration(device: nvmlDevice_t,
                                               currLinkGen:
                                                   *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrPcieLinkWidth(device: nvmlDevice_t,
                                          currLinkWidth:
                                              *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPcieThroughput(device: nvmlDevice_t,
                                       counter: nvmlPcieUtilCounter_t,
                                       value: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPcieReplayCounter(device: nvmlDevice_t,
                                          value: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetClockInfo(device: nvmlDevice_t,
                                  type_: nvmlClockType_t,
                                  clock: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxClockInfo(device: nvmlDevice_t,
                                     type_: nvmlClockType_t,
                                     clock: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetApplicationsClock(device: nvmlDevice_t,
                                          clockType: nvmlClockType_t,
                                          clockMHz:
                                              *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDefaultApplicationsClock(device: nvmlDevice_t,
                                                 clockType: nvmlClockType_t,
                                                 clockMHz:
                                                     *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetApplicationsClocks(device: nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetClock(device: nvmlDevice_t,
                              clockType: nvmlClockType_t,
                              clockId: nvmlClockId_t,
                              clockMHz: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMaxCustomerBoostClock(device: nvmlDevice_t,
                                              clockType: nvmlClockType_t,
                                              clockMHz:
                                                  *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedMemoryClocks(device: nvmlDevice_t,
                                              count:
                                                  *mut ::std::os::raw::c_uint,
                                              clocksMHz:
                                                  *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedGraphicsClocks(device: nvmlDevice_t,
                                                memoryClockMHz:
                                                    ::std::os::raw::c_uint,
                                                count:
                                                    *mut ::std::os::raw::c_uint,
                                                clocksMHz:
                                                    *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                 isEnabled:
                                                     *mut nvmlEnableState_t,
                                                 defaultIsEnabled:
                                                     *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                 enabled: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(device: nvmlDevice_t,
                                                        enabled:
                                                            nvmlEnableState_t,
                                                        flags:
                                                            ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetFanSpeed(device: nvmlDevice_t,
                                 speed: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTemperature(device: nvmlDevice_t,
                                    sensorType: nvmlTemperatureSensors_t,
                                    temp: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTemperatureThreshold(device: nvmlDevice_t,
                                             thresholdType:
                                                 nvmlTemperatureThresholds_t,
                                             temp:
                                                 *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPerformanceState(device: nvmlDevice_t,
                                         pState: *mut nvmlPstates_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCurrentClocksThrottleReasons(device: nvmlDevice_t,
                                                     clocksThrottleReasons:
                                                         *mut ::std::os::raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedClocksThrottleReasons(device: nvmlDevice_t,
                                                       supportedClocksThrottleReasons:
                                                           *mut ::std::os::raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerState(device: nvmlDevice_t,
                                   pState: *mut nvmlPstates_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementMode(device: nvmlDevice_t,
                                            mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementLimit(device: nvmlDevice_t,
                                             limit:
                                                 *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementLimitConstraints(device: nvmlDevice_t,
                                                        minLimit:
                                                            *mut ::std::os::raw::c_uint,
                                                        maxLimit:
                                                            *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerManagementDefaultLimit(device: nvmlDevice_t,
                                                    defaultLimit:
                                                        *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPowerUsage(device: nvmlDevice_t,
                                   power: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEnforcedPowerLimit(device: nvmlDevice_t,
                                           limit: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetGpuOperationMode(device: nvmlDevice_t,
                                         current: *mut nvmlGpuOperationMode_t,
                                         pending: *mut nvmlGpuOperationMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMemoryInfo(device: nvmlDevice_t,
                                   memory: *mut nvmlMemory_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetComputeMode(device: nvmlDevice_t,
                                    mode: *mut nvmlComputeMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEccMode(device: nvmlDevice_t,
                                current: *mut nvmlEnableState_t,
                                pending: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBoardId(device: nvmlDevice_t,
                                boardId: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMultiGpuBoard(device: nvmlDevice_t,
                                      multiGpuBool:
                                          *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetTotalEccErrors(device: nvmlDevice_t,
                                       errorType: nvmlMemoryErrorType_t,
                                       counterType: nvmlEccCounterType_t,
                                       eccCounts:
                                           *mut ::std::os::raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDetailedEccErrors(device: nvmlDevice_t,
                                          errorType: nvmlMemoryErrorType_t,
                                          counterType: nvmlEccCounterType_t,
                                          eccCounts:
                                              *mut nvmlEccErrorCounts_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetMemoryErrorCounter(device: nvmlDevice_t,
                                           errorType: nvmlMemoryErrorType_t,
                                           counterType: nvmlEccCounterType_t,
                                           locationType: nvmlMemoryLocation_t,
                                           count:
                                               *mut ::std::os::raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetUtilizationRates(device: nvmlDevice_t,
                                         utilization: *mut nvmlUtilization_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetEncoderUtilization(device: nvmlDevice_t,
                                           utilization:
                                               *mut ::std::os::raw::c_uint,
                                           samplingPeriodUs:
                                               *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDecoderUtilization(device: nvmlDevice_t,
                                           utilization:
                                               *mut ::std::os::raw::c_uint,
                                           samplingPeriodUs:
                                               *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetDriverModel(device: nvmlDevice_t,
                                    current: *mut nvmlDriverModel_t,
                                    pending: *mut nvmlDriverModel_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetVbiosVersion(device: nvmlDevice_t,
                                     version: *mut ::std::os::raw::c_char,
                                     length: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBridgeChipInfo(device: nvmlDevice_t,
                                       bridgeHierarchy:
                                           *mut nvmlBridgeChipHierarchy_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetComputeRunningProcesses(device: nvmlDevice_t,
                                                infoCount:
                                                    *mut ::std::os::raw::c_uint,
                                                infos: *mut nvmlProcessInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetGraphicsRunningProcesses(device: nvmlDevice_t,
                                                 infoCount:
                                                     *mut ::std::os::raw::c_uint,
                                                 infos:
                                                     *mut nvmlProcessInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceOnSameBoard(device1: nvmlDevice_t, device2: nvmlDevice_t,
                                 onSameBoard: *mut ::std::os::raw::c_int)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAPIRestriction(device: nvmlDevice_t,
                                       apiType: nvmlRestrictedAPI_t,
                                       isRestricted: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
#[cfg(feature = "nightly")]
extern "C" {
    pub fn nvmlDeviceGetSamples(device: nvmlDevice_t,
                                type_: nvmlSamplingType_t,
                                lastSeenTimeStamp:
                                    ::std::os::raw::c_ulonglong,
                                sampleValType: *mut nvmlValueType_t,
                                sampleCount: *mut ::std::os::raw::c_uint,
                                samples: *mut nvmlSample_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetBAR1MemoryInfo(device: nvmlDevice_t,
                                       bar1Memory: *mut nvmlBAR1Memory_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetViolationStatus(device: nvmlDevice_t,
                                        perfPolicyType: nvmlPerfPolicyType_t,
                                        violTime: *mut nvmlViolationTime_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingMode(device: nvmlDevice_t,
                                       mode: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingStats(device: nvmlDevice_t,
                                        pid: ::std::os::raw::c_uint,
                                        stats: *mut nvmlAccountingStats_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingPids(device: nvmlDevice_t,
                                       count: *mut ::std::os::raw::c_uint,
                                       pids: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetAccountingBufferSize(device: nvmlDevice_t,
                                             bufferSize:
                                                 *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetRetiredPages(device: nvmlDevice_t,
                                     cause: nvmlPageRetirementCause_t,
                                     pageCount: *mut ::std::os::raw::c_uint,
                                     addresses:
                                         *mut ::std::os::raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetRetiredPagesPendingStatus(device: nvmlDevice_t,
                                                  isPending:
                                                      *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlUnitSetLedState(unit: nvmlUnit_t, color: nvmlLedColor_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetPersistenceMode(device: nvmlDevice_t,
                                        mode: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetComputeMode(device: nvmlDevice_t,
                                    mode: nvmlComputeMode_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetEccMode(device: nvmlDevice_t, ecc: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearEccErrorCounts(device: nvmlDevice_t,
                                         counterType: nvmlEccCounterType_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetDriverModel(device: nvmlDevice_t,
                                    driverModel: nvmlDriverModel_t,
                                    flags: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetApplicationsClocks(device: nvmlDevice_t,
                                           memClockMHz:
                                               ::std::os::raw::c_uint,
                                           graphicsClockMHz:
                                               ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetPowerManagementLimit(device: nvmlDevice_t,
                                             limit: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetGpuOperationMode(device: nvmlDevice_t,
                                         mode: nvmlGpuOperationMode_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAPIRestriction(device: nvmlDevice_t,
                                       apiType: nvmlRestrictedAPI_t,
                                       isRestricted: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetAccountingMode(device: nvmlDevice_t,
                                       mode: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceClearAccountingPids(device: nvmlDevice_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkState(device: nvmlDevice_t,
                                    link: ::std::os::raw::c_uint,
                                    isActive: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkVersion(device: nvmlDevice_t,
                                      link: ::std::os::raw::c_uint,
                                      version: *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkCapability(device: nvmlDevice_t,
                                         link: ::std::os::raw::c_uint,
                                         capability: nvmlNvLinkCapability_t,
                                         capResult:
                                             *mut ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkRemotePciInfo(device: nvmlDevice_t,
                                            link: ::std::os::raw::c_uint,
                                            pci: *mut nvmlPciInfo_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkErrorCounter(device: nvmlDevice_t,
                                           link: ::std::os::raw::c_uint,
                                           counter: nvmlNvLinkErrorCounter_t,
                                           counterValue:
                                               *mut ::std::os::raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetNvLinkErrorCounters(device: nvmlDevice_t,
                                              link: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceSetNvLinkUtilizationControl(device: nvmlDevice_t,
                                                 link: ::std::os::raw::c_uint,
                                                 counter:
                                                     ::std::os::raw::c_uint,
                                                 control:
                                                     *mut nvmlNvLinkUtilizationControl_t,
                                                 reset:
                                                     ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkUtilizationControl(device: nvmlDevice_t,
                                                 link: ::std::os::raw::c_uint,
                                                 counter:
                                                     ::std::os::raw::c_uint,
                                                 control:
                                                     *mut nvmlNvLinkUtilizationControl_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                 link: ::std::os::raw::c_uint,
                                                 counter:
                                                     ::std::os::raw::c_uint,
                                                 rxcounter:
                                                     *mut ::std::os::raw::c_ulonglong,
                                                 txcounter:
                                                     *mut ::std::os::raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceFreezeNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                    link:
                                                        ::std::os::raw::c_uint,
                                                    counter:
                                                        ::std::os::raw::c_uint,
                                                    freeze: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceResetNvLinkUtilizationCounter(device: nvmlDevice_t,
                                                   link:
                                                       ::std::os::raw::c_uint,
                                                   counter:
                                                       ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetCreate(set: *mut nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceRegisterEvents(device: nvmlDevice_t,
                                    eventTypes: ::std::os::raw::c_ulonglong,
                                    set: nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetSupportedEventTypes(device: nvmlDevice_t,
                                            eventTypes:
                                                *mut ::std::os::raw::c_ulonglong)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetWait(set: nvmlEventSet_t, data: *mut nvmlEventData_t,
                            timeoutms: ::std::os::raw::c_uint)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlEventSetFree(set: nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceModifyDrainState(pciInfo: *mut nvmlPciInfo_t,
                                      newState: nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceQueryDrainState(pciInfo: *mut nvmlPciInfo_t,
                                     currentState: *mut nvmlEnableState_t)
     -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceRemoveGpu(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceDiscoverGpus(pciInfo: *mut nvmlPciInfo_t)
     -> nvmlReturn_t;
}
